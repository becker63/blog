This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
app/
  Blogs/
    [slug]/
      layout.tsx
      loading.tsx
      page.tsx
  components/
    blog/
      BlogNavbarWrapper.tsx
    home/
      Bebop.tsx
      BebopContainer.tsx
      Card.tsx
      HomeDesktopLayout.tsx
      HomeMobileLayout.tsx
      HomeNav.tsx
      index.ts
      LatestBlogCard.tsx
      MobileScrollContainer.tsx
      Socials.tsx
    search/
      Badges.tsx
      BlogCard.tsx
      index.ts
      SearchWrapper.tsx
      TreeLines.tsx
      TreeNode.tsx
      treeNodeMachine.ts
    shared/
      AnimatedCard.tsx
      GlassCard.tsx
      index.ts
      Loading.tsx
      Navbar.tsx
      Route.tsx
      shared.css
  Search/
    layout.tsx
    loading.tsx
    page.tsx
  globals.css
  layout.tsx
  page.tsx
content/
  posts/
    designing-for-two.mdx
    tight-loops.mdx
hooks/
  index.ts
  useMobileDetection.ts
  useScrollFadeAnimation.ts
lib/
  animationDelay.ts
  blogs.ts
  layout.ts
  mdx.ts
public/
  fonts/
    pixeldown.ttf
  img/
    backgroundImage.jpg
    laptop.jpeg
    stickmen.png
    wallpaper4.jpg
tests/
  utils/
    gap-utils.ts
  gap-consistency.spec.ts
  layout.spec.ts
  mobile-navbar.spec.ts
  navbar-overlap.spec.ts
  svg-visibility.spec.ts
  tree-line-continuity.spec.ts
.eslintrc
.gitignore
flake.lock
flake.nix
next.config.js
package.json
panda.config.ts
postcss.config.cjs
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/Blogs/[slug]/loading.tsx">
import { Loading } from "../../components/shared/Loading";

export default function loading() {
  return (
    <div className="w-screen h-screen flex justify-center items-center">
      <Loading fontsize={100} />
    </div>
  );
}
</file>

<file path="app/components/blog/BlogNavbarWrapper.tsx">
"use client";

import { motion } from "framer-motion";
import { ReactNode } from "react";
import { useScrollFadeAnimation } from "../../../hooks";

interface BlogNavbarWrapperProps {
    children: ReactNode;
}

/**
 * Client-side wrapper that makes the navbar fade away on scroll
 * for the blog slug pages.
 */
export const BlogNavbarWrapper = ({ children }: BlogNavbarWrapperProps) => {
    const { opacity, y } = useScrollFadeAnimation();

    return (
        <motion.div
            style={{
                opacity,
                y,
            }}
        >
            {children}
        </motion.div>
    );
};
</file>

<file path="app/components/home/Bebop.tsx">
'use client';
import { motion } from "framer-motion";
import SVG from 'react-inlinesvg';
import { css } from "../../../styled-system/css";

export const Bebop = () => {
    return (
        <motion.div
            initial={{ opacity: 0, scale: 0.95 }}
            animate={{ opacity: 1, scale: 1 }}
            transition={{ duration: 0.8, ease: "easeOut" }}
            style={{ position: 'absolute', top: 0, left: 0, width: '100%', height: '100%' }}
            className={css({
                position: 'absolute',
                top: 0,
                left: 0,
                w: '100%',
                h: '100%',
                display: 'flex',
                justifyContent: 'center',
                alignItems: 'center',
            })}
        >
            <SVG
                src="/svg/bebop.svg"
                width="100%"
                height="100%"
                style={{ width: '100%', height: '100%', display: 'block' }}
                preserveAspectRatio="xMidYMid meet"
                className={css({
                    w: '100%',
                    h: '100%',
                    display: 'block'
                })}
            />
        </motion.div >
    );
};
</file>

<file path="app/components/home/BebopContainer.tsx">
import { css } from "../../../styled-system/css";
import { Bebop } from "./Bebop";

/**
 * Container component for the Bebop SVG on desktop layout.
 * Centers the SVG and adds the "see ya space cowboy" tagline.
 */
export const BebopContainer = () => {
    return (
        <div
            className={css({
                lg: { w: "100%" },
                alignItems: "center",
                display: "flex",
                flexDirection: "column",
                alignContent: "center",
                justifyContent: "center",
                h: "100%",
                overflow: "hidden",
            })}
        >
            <div className={css({
                position: "relative",
                w: "100%",
                h: "100%",
                display: "flex",
                flexDirection: "column",
                flex: 1,
                minHeight: 0,
                alignItems: "center",
                justifyContent: "center"
            })}>
                <Bebop />
            </div>
            <p className={css({ pr: "16", textAlign: "right" })}>
                see ya space cowboy...
            </p>
        </div>
    );
};
</file>

<file path="app/components/home/HomeDesktopLayout.tsx">
import * as React from "react";
import { css } from "../../../styled-system/css";
import { HomeNav } from "./HomeNav";
import { LatestBlogCard } from "./LatestBlogCard";
import { Card, Socials, BebopContainer } from ".";
import { glassCardStyles } from "../shared/GlassCard";
import { AnimatedCard } from "../shared/AnimatedCard";
import { seededDelay } from "../../../lib/animationDelay";
import { faPaperclip } from "@fortawesome/free-solid-svg-icons";
import { faMarkdown } from "@fortawesome/free-brands-svg-icons";

export const HomeDesktopLayout = () => {
  return (
    <>
      <div className={css({ display: "none", lg: { display: "block" } })}>
        <HomeNav />
      </div>

      <div
        className={css({
          display: "none",
          lg: { display: "flex" },
          layerStyle: "pageContainer",
          h: "100vh",
          w: "100vw",
          flexDirection: "column",
          minH: 0,
          overflow: "hidden",
        })}
      >
        <div
          className={css({
            alignSelf: "center",
            w: "95%",
            maxWidth: "1250px",
            display: "grid",
            gridTemplateColumns: "minmax(0, 2fr) minmax(0, 1fr)",
            gridTemplateRows:
              "minmax(0, 1fr) minmax(0, 1fr) minmax(0, 2fr) minmax(0, 1fr)",
            gridGap: "layout",
            gridTemplateAreas: `
              "Svg Blog"
              "Svg Latest-Blog"
              "Svg Latest-Blog"
              "Socials CV"
            `,
            flex: "1",
            h: 0,
          })}
        >
          <AnimatedCard
            delay={seededDelay("bebop-desktop")}
            className={css({
              ...glassCardStyles,
              gridArea: "Svg",
              position: "relative",
              display: "flex",
              justifyContent: "center",
              alignItems: "stretch",
              overflow: "hidden",
            })}
          >
            <BebopContainer />
          </AnimatedCard>

          <AnimatedCard
            delay={seededDelay("resume-desktop")}
            className={css({
              ...glassCardStyles,
              gridArea: "CV",
              display: "flex",
              flexDirection: "column",
              justifyContent: "center",
              px: { base: "5", sm: "20", lg: "5" },
              py: "5",
            })}
          >
            <Card
              title="Resume"
              desc="My Background."
              color="#86efac"
              href="https://docs.google.com/document/d/1PVuM1n5Q1qQNWRAvfe058KQaeYeUVvKFx681bQuDjVE/edit?usp=sharing"
              icon={faPaperclip}
            />
          </AnimatedCard>

          <AnimatedCard
            delay={seededDelay("blogs-desktop")}
            className={css({
              ...glassCardStyles,
              gridArea: "Blog",
              display: "flex",
              flexDirection: "column",
              justifyContent: "center",
              px: { base: "5", sm: "20", lg: "5" },
              py: "5",
            })}
          >
            <Card
              title="Blogs"
              desc="Search through my back catalog."
              color="#fca5a5"
              href="/Search"
              icon={faMarkdown}
            />
          </AnimatedCard>

          <AnimatedCard
            delay={seededDelay("latest-desktop")}
            className={css({
              ...glassCardStyles,
              gridArea: "Latest-Blog",
              display: "flex",
              flexDirection: "column",
              justifyContent: "center",
              position: "relative",
            })}
          >
            <LatestBlogCard />
          </AnimatedCard>

          <AnimatedCard
            delay={seededDelay("socials-desktop")}
            className={css({
              ...glassCardStyles,
              gridArea: "Socials",
              display: "flex",
              flexDirection: "column",
              justifyContent: "center",
              py: "5",
            })}
          >
            <Socials />
          </AnimatedCard>
        </div>
      </div>
    </>
  );
};
</file>

<file path="app/components/home/HomeMobileLayout.tsx">
import * as React from "react";
import { css } from "../../../styled-system/css";
import { Bebop } from "./Bebop";
import { HomeNav } from "./HomeNav";
import { MobileLayout } from "./MobileScrollContainer";
import { LatestBlogCard } from "./LatestBlogCard";
import { Card, Socials } from ".";
import { glassCardStyles } from "../shared/GlassCard";
import { AnimatedCard } from "../shared/AnimatedCard";
import { faPaperclip } from "@fortawesome/free-solid-svg-icons";
import { faMarkdown } from "@fortawesome/free-brands-svg-icons";

export const HomeMobileLayout = () => {
  return (
    <MobileLayout navbar={<HomeNav inline />}>
      <AnimatedCard
        index={0}
        className={css({
          ...glassCardStyles,
          w: "90vw",
          minH: "300px",
          position: "relative",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          overflow: "hidden",
        })}
      >
        <div
          className={css({
            w: "90%",
            display: "flex",
            flexDirection: "column",
            alignItems: "center",
            position: "relative",
            aspectRatio: "1042 / 1066",
            maxH: "50vh",
          })}
        >
          <Bebop />
          <p
            className={css({
              pr: "11",
              textAlign: "right",
              position: "absolute",
              bottom: 0,
              right: 0,
            })}
          >
            see ya space cowboy...
          </p>
        </div>
      </AnimatedCard>

      <div
        className={css({
          alignSelf: "center",
          w: "90vw",
          display: "flex",
          flexDirection: "column",
          gap: "layout",
          mt: "layout",
          pb: "layout",
        })}
      >
        <AnimatedCard
          index={1}
          className={css({
            ...glassCardStyles,
            h: "95px",
            display: "flex",
            flexDirection: "column",
            justifyContent: "center",
            px: { base: "5", sm: "20" },
          })}
        >
          <Card
            title="Resume"
            desc="My Background."
            color="#86efac"
            href="https://docs.google.com/document/d/1PVuM1n5Q1qQNWRAvfe058KQaeYeUVvKFx681bQuDjVE/edit?usp=sharing"
            icon={faPaperclip}
          />
        </AnimatedCard>

        <AnimatedCard
          index={2}
          className={css({
            ...glassCardStyles,
            h: "95px",
            display: "flex",
            flexDirection: "column",
            justifyContent: "center",
            px: { base: "5", sm: "20" },
          })}
        >
          <Card
            title="Blogs"
            desc="Search through my back catalog."
            color="#fca5a5"
            href="/Search"
            icon={faMarkdown}
          />
        </AnimatedCard>

        <AnimatedCard
          index={3}
          className={css({
            ...glassCardStyles,
            h: "400px",
            display: "flex",
            flexDirection: "column",
            justifyContent: "center",
          })}
        >
          <LatestBlogCard />
        </AnimatedCard>

        <AnimatedCard
          index={4}
          className={css({
            ...glassCardStyles,
            h: "95px",
            display: "flex",
            flexDirection: "column",
            justifyContent: "center",
          })}
        >
          <Socials />
        </AnimatedCard>
      </div>
    </MobileLayout>
  );
};
</file>

<file path="app/components/home/HomeNav.tsx">
import { css } from "../../../styled-system/css";

interface HomeNavProps {
  /** When true, removes fixed positioning (for mobile layout integration) */
  inline?: boolean;
}

export const HomeNav = ({ inline = false }: HomeNavProps) => {
  return (
    <nav
      className={css({
        layerStyle: "navbar",
        // For inline mode: use relative positioning and full width
        // Override the fixed positioning values from layerStyle
        position: inline ? "relative" : "fixed",
        w: inline ? "100%" : undefined,
        left: inline ? "unset" : undefined,
        right: inline ? "unset" : undefined,
        top: inline ? "unset" : undefined,
        mb: inline ? "0" : undefined, // MobileLayout handles the gap
      })}
    >
      <div
        className={css({
          display: "flex",
          flexWrap: "wrap",
          justifyContent: "center",
          alignItems: "center",
          mx: "auto",
          w: "100%",
          maxW: "1536px", // 2xl
        })}
      >
        {/* home view */}
        <div className={css({ display: "flex" })}>
          <span
            className={`anim-typewriter ${css({
              alignSelf: "center",
              fontSize: "30px",
              fontWeight: "semibold",
              whiteSpace: "nowrap",
              _dark: { color: "white" },
              color: "white",
              fontFamily: "pixel",
            })}`}
          >
            becker63
          </span>
        </div>
      </div>
    </nav>
  );
};
</file>

<file path="app/components/home/Socials.tsx">
import { css } from "../../../styled-system/css";
import { Route } from "../shared/Route";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import {
    faGithub,
    faInstagram,
    faLinkedin,
} from "@fortawesome/free-brands-svg-icons";
import { faEnvelope } from "@fortawesome/free-solid-svg-icons";

/**
 * Social media links component with dividers.
 * Displays GitHub, LinkedIn, Email, and Instagram icons.
 */
export const Socials = () => (
    <div
        className={css({
            display: "flex",
            flexDirection: "row",
            justifyContent: "space-evenly",
            height: "80%",
        })}
    >
        <div
            className={css({ display: "flex", flexDirection: "column", justifyContent: "center" })}
        >
            <Route href={"https://github.com/becker63"} size={30}>
                <FontAwesomeIcon
                    icon={faGithub}
                    size="2xl"
                    className={css({ _hover: { color: "#575757" } })}
                />
            </Route>
        </div>
        <div
            className={css({
                w: "1px",
                bg: "white",
                float: "left",
                h: "80%",
                alignSelf: "center",
            })}
        />
        <div
            className={css({ display: "flex", flexDirection: "column", justifyContent: "center" })}
        >
            <Route href={"https://www.linkedin.com/in/taylor-johnson-805061210/"} size={30}>
                <FontAwesomeIcon
                    icon={faLinkedin}
                    size="2xl"
                    className={css({ _hover: { color: "#ff63a4" } })}
                />
            </Route>
        </div>
        <div
            className={css({
                w: "1px",
                bg: "white",
                float: "left",
                h: "80%",
                alignSelf: "center",
            })}
        />
        <div
            className={css({ display: "flex", flexDirection: "column", justifyContent: "center" })}
        >
            <Route href={"mailto:johnsontaylor6320@gmail.com"} size={30}>
                <FontAwesomeIcon
                    icon={faEnvelope}
                    size="2xl"
                    className={css({ _hover: { color: "#06c1ff" } })}
                />
            </Route>
        </div>
        <div
            className={css({
                w: "1px",
                bg: "white",
                float: "left",
                h: "80%",
                alignSelf: "center",
            })}
        />
        <div
            className={css({ display: "flex", flexDirection: "column", justifyContent: "center" })}
        >
            <Route href={"https://www.instagram.com/taylorjohnson63200"} size={30}>
                <FontAwesomeIcon
                    icon={faInstagram}
                    size="2xl"
                    className={css({ _hover: { color: "#7301ff" } })}
                />
            </Route>
        </div>
    </div>
);
</file>

<file path="app/components/search/BlogCard.tsx">
import { motion } from "framer-motion";
import { css } from "../../../styled-system/css";
import Link from "next/link";
import Image from "next/image";
import { BlogPost } from "../../../lib/blogs";
import { DescriptionTags, tags } from "./Badges";

export const BlogCard = ({ blog }: { blog: BlogPost }) => {
  const DescripTags = DescriptionTags(blog.meta.tags as tags[]);
  const hasImage = blog.meta.image !== undefined;

  const truncatedDesc =
    blog.meta.description.length > 100
      ? blog.meta.description.slice(0, 100) + "..."
      : blog.meta.description;

  return (
    <motion.div
      initial={{ opacity: 0, y: 12 }}
      animate={{ opacity: 0.7, y: 0 }} // üëà animate to your glass opacity
      exit={{ opacity: 0, y: 12 }}
      transition={{ duration: 0.35, ease: "easeOut" }}
      className={css({
        flex: 1,
        minW: 0,
        color: "gray.800",
        px: "5",
        py: "5",
        borderRadius: "10px",
        boxShadow: "#00000F 0 0 10px",
        bg: "#000000",
      })}
    >
      <Link href={"/Blogs/" + blog.slug} className={css({ display: "block" })}>
        <div className={css({ display: "flex", flexDirection: "column" })}>
          <h3
            className={css({
              fontSize: "xl",
              fontWeight: "bold",
              color: "white",
              mb: "1",
            })}
          >
            {blog.meta.title}
          </h3>

          <p className={css({ color: "gray.400", mb: "2" })}>{truncatedDesc}</p>

          <div
            className={css({
              display: "flex",
              flexWrap: "wrap",
              alignItems: "center",
              gap: "2",
            })}
          >
            <span className={css({ color: "gray.200", fontSize: "sm" })}>
              {blog.meta.date}
            </span>
            <div>{DescripTags}</div>
          </div>
        </div>

        {hasImage && (
          <div
            className={css({
              display: "flex",
              justifyContent: "center",
              mt: "3",
            })}
          >
            <Image
              src={blog.meta.image!}
              alt="blogcontent"
              width={200}
              height={200}
            />
          </div>
        )}
      </Link>
    </motion.div>
  );
};
</file>

<file path="app/components/search/index.ts">
/**
 * Search-related components
 */

export { DescriptionTags } from "./Badges";
export type { tags } from "./Badges";

export { SearchWrapper } from "./SearchWrapper";
</file>

<file path="app/components/search/TreeLines.tsx">
import { css } from "../../../styled-system/css";
import { motion } from "framer-motion";

const LAYOUT_GAP = "16px";
const LINE_WIDTH = "2px";
const BRANCH_LENGTH = "20px";
export const TREE_COLUMN_WIDTH = `calc(0px + ${BRANCH_LENGTH})`;

type Props = {
  showTop: boolean;
  showBottom: boolean;
};

export const TreeLines = ({ showTop, showBottom }: Props) => (
  <div
    className={css({
      flexShrink: 0,
      width: TREE_COLUMN_WIDTH,
      position: "relative",
      pointerEvents: "none",
    })}
  >
    {(showTop || showBottom) && (
      <motion.div
        initial={{ scaleY: 0 }}
        animate={{ scaleY: 1 }}
        transition={{ duration: 0.35, ease: "easeOut" }}
        style={{
          transformOrigin: "top",
          position: "absolute",
          left: 0,
          width: LINE_WIDTH,
          background: "white",
          top: showTop ? `calc(-${LAYOUT_GAP} / 2)` : "50%",
          bottom: showBottom ? `calc(-${LAYOUT_GAP} / 2)` : "50%",
        }}
      />
    )}

    <motion.div
      initial={{ scaleX: 0 }}
      animate={{ scaleX: 1 }}
      transition={{ duration: 0.25, delay: 0.15 }}
      style={{
        transformOrigin: "left",
        position: "absolute",
        top: "50%",
        left: 0,
        height: LINE_WIDTH,
        width: BRANCH_LENGTH,
        background: "white",
      }}
    />
  </div>
);
</file>

<file path="app/components/search/TreeNode.tsx">
"use client";

import React from "react";
import { useMachine } from "@xstate/react";
import { treeNodeMachine } from "./treeNodeMachine";
import { css } from "../../../styled-system/css";
import { BlogPost } from "../../../lib/blogs";
import { TreeLines, TREE_COLUMN_WIDTH } from "./TreeLines";
import { BlogCard } from "./BlogCard";

type TreeNodeProps = {
  blog: BlogPost;
  depth: number;
  isFirst: boolean;
  isLast: boolean;
};

export const TreeNode = ({ blog, depth, isFirst, isLast }: TreeNodeProps) => {
  useMachine(treeNodeMachine);

  return (
    <>
      <div
        className={css({
          display: "flex",
          justifyContent: "center",
          w: "full",
        })}
      >
        <div
          className={css({
            display: "flex",
            flexDirection: "row",
            w: "full",
            maxW: "800px",
          })}
        >
          {/* Indentation */}
          {Array.from({ length: depth }).map((_, i) => (
            <div key={i} style={{ width: TREE_COLUMN_WIDTH }} />
          ))}

          <TreeLines showTop={!isFirst} showBottom={!isLast} />
          <BlogCard blog={blog} />
        </div>
      </div>

      {blog.children?.map((child, index) => (
        <TreeNode
          key={child.slug}
          blog={child}
          depth={depth + 1}
          isFirst={index === 0}
          isLast={index === blog.children!.length - 1}
        />
      ))}
    </>
  );
};
</file>

<file path="app/components/search/treeNodeMachine.ts">
import { createMachine } from "xstate";

export const treeNodeMachine = createMachine({
  id: "treeNode",
  initial: "visible",
  states: {
    visible: {}, // later: expanded/collapsed/etc
  },
});
</file>

<file path="app/components/shared/AnimatedCard.tsx">
"use client";

import { motion, HTMLMotionProps, useReducedMotion } from "framer-motion";
import React from "react";
import { cx } from "../../../styled-system/css";

type AnimatedCardProps = HTMLMotionProps<"div"> & {
  delay?: number;
  index?: number;
  finalOpacity?: number;
};

export const AnimatedCard = React.forwardRef<HTMLDivElement, AnimatedCardProps>(
  (
    { delay, index, finalOpacity = 0.7, className, style, children, ...rest },
    ref,
  ) => {
    const prefersReducedMotion = useReducedMotion();
    const computedDelay = index !== undefined ? index * 0.06 : delay ?? 0;

    return (
      <motion.div
        ref={ref}
        initial={prefersReducedMotion ? false : { opacity: 0, y: 10 }}
        animate={prefersReducedMotion ? {} : { opacity: finalOpacity, y: 0 }}
        transition={{
          duration: 0.4,
          delay: computedDelay,
          ease: [0.22, 1, 0.36, 1],
        }}
        className={cx(className)}
        style={{
          ...style,
          willChange: "transform, opacity",
        }}
        {...rest}
      >
        {children}
      </motion.div>
    );
  },
);

AnimatedCard.displayName = "AnimatedCard";
</file>

<file path="app/components/shared/GlassCard.tsx">
import { ReactNode } from "react";
import { css, cx } from "../../../styled-system/css";
import { SystemStyleObject } from "../../../styled-system/types";

export interface GlassCardProps {
    children: ReactNode;
    /** Additional Panda CSS styles to merge */
    styles?: SystemStyleObject;
    /** CSS class name */
    className?: string;
}

/**
 * Reusable glass-effect card component with consistent styling.
 * Provides the semi-transparent black background with border radius and shadow
 * used throughout the homepage.
 */
export const GlassCard = ({ children, styles, className }: GlassCardProps) => {
    return (
        <div
            className={cx(
                css({
                    bg: "#000000",
                    opacity: 0.7,
                    borderRadius: "10px",
                    boxShadow: "#00000F 0 0 10px",
                    ...styles,
                }),
                className
            )}
        >
            {children}
        </div>
    );
};

/**
 * Common glass card style object for use with css() when GlassCard component isn't suitable.
 */
export const glassCardStyles = {
    bg: "#000000",
    opacity: 0.7,
    borderRadius: "10px",
    boxShadow: "#00000F 0 0 10px",
} as const;
</file>

<file path="app/components/shared/index.ts">
/**
 * Shared components used across the application
 */

export { GlassCard, glassCardStyles } from "./GlassCard";
export type { GlassCardProps } from "./GlassCard";

export { Route } from "./Route";
export type { RouteProps } from "./Route";

export { Loading } from "./Loading";
export type { LoadingProps } from "./Loading";

export { Navbar } from "./Navbar";
export type { NavbarProps } from "./Navbar";
</file>

<file path="app/components/shared/Loading.tsx">
import "./shared.css";

export interface LoadingProps {
    fontsize: number;
}

/**
 * Simple loading indicator component.
 */
export function Loading({ fontsize }: LoadingProps) {
    return (
        <div className="loading text-white" style={{ fontSize: fontsize.toString() + "px" }}>
            <h1>...</h1>
        </div>
    );
}
</file>

<file path="app/components/shared/shared.css">
/* Animation */

.loading {
  display: inline-block;
  clip-path: inset(0 100% 0 0);
  animation: dots 300ms steps(4) infinite;
}


@keyframes dots {
  to {
    clip-path: inset(0 -100% 0 0);
  }
}
</file>

<file path="app/Search/layout.tsx">
import { Navbar } from "../components/shared/Navbar";

export const metadata = {
  title: 'Homepage',
  description: 'Generated by create next app',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <>
      <Navbar />
      <div>{children}</div>
    </>
  )
}
</file>

<file path="app/Search/loading.tsx">
import { Loading } from "../components/shared/Loading";

export default function loading() {
  return (
    <div className="w-screen h-screen flex justify-center items-center">
      <Loading fontsize={100} />
    </div>
  );
}
</file>

<file path="content/posts/tight-loops.mdx">
---
title: Tight Loops
date: '25 January 2026'
description: How frontend instincts about tooling and feedback loops shaped a structured fuzzing workflow.
tags: tech
---

Believe it or not I used to be a frontend guy. Like a real frontend guy. I did the spa thing, I wrote react. I did the things the industry tells you your not supposed to do in order to move fast. At one of my jobs I owned a fork of Chartjs. 

So yeah, I was deep in it. And honestly, that was fine, because the problems I was solving _did_ genuinely require the kinds of complex architectures the modern web incentivizes. My early battle scars came from fighting state-management libraries like Recoil (which was still relatively new at the time), and from interfacing with strange windowing libraries like `react-mosaic`. Then I had to take all of that and iteratively plumb _just enough_ of it together to turn into something demoable.

But what actually made that work possible ‚Äî what made frontend _fast_ ‚Äî wasn‚Äôt React itself, or clever abstractions. It was the fact that frontend development lives inside an unusually consistent runtime environment, backed by extremely strong build and tooling conventions.

CLIs, project templates, formatters, hot reloaders, package managers, and predictable dev servers meant that you could spin something up quickly, share it immediately, and expect it to behave roughly the same on someone else‚Äôs machine. The setup path was well-worn. The feedback loop was tight. You spent your time _inside_ the problem, not negotiating the environment.

I‚Äôm sharing this frontend background because that need to productize, to move quickly, to package work so it‚Äôs legible and runnable by someone else, to ship something that looks intentional to users rather than impressive only to engineers, has deeply infected how I work. Even when the work is abstract or low-level, I instinctively wrap it in tooling, structure, and affordances.

I think that producty mother tongue, my first language, and the habits it produced mostly serve me well, especially as I work almost exclusively in technical layers of the stack. What frontend really taught me wasn‚Äôt exclusively UI polish, it was how much speed comes from a consistent runtime environment and good tooling.

When I‚Äôm deep in a system and I see a nice Makefile, a CMake setup, a Bash script, or even someone pointing to proper setup docs, I see the person behind the repo who put in the non-trivial effort to make the project easier to understand and less of a burden for the next person.

And to me, that effort isn‚Äôt just courtesy. You can feel how much faster you‚Äôre able to move when setup code is reliable and you let your computer do work for you. The feedback loop tightens in the same way it does in application or web development.

You can fork casually, move things around in non-trivial ways, make fewer assumptions, and you stop hearing ‚Äúit doesn‚Äôt run on my machine.‚Äù

That‚Äôs what lets you explore novel state spaces faster.

You know what else does that?

---
## Coverage guided fuzzing

Coverage guided fuzzing is one way of turning program behavior into a search problem.

The basic loop is simple: generate inputs, observe execution, keep the ones that lead somewhere new. Coverage is just one heuristic for ‚Äúnewness‚Äù among many. It‚Äôs not a guarantee of correctness or completeness, and it‚Äôs not especially interesting on its own.

What *is* interesting is the workflow it enables.

Instead of manually enumerating cases or relying on intuition about where a system might break, you define a boundary, give the machine a signal, and let it explore. The tighter and more reliable that loop is, the more useful it becomes. Most of the work ends up looking less like writing tests and more like designing the surface the fuzzer is allowed to search.

That framing is what drew me to fuzzing here. Not as a vulnerability-hunting technique, but as a way to externalize exploration and reduce the amount of implicit reasoning I was doing by hand.

## libnftnl/libmnl motivation

The concrete system I ended up exploring this way was nftables‚Äô userland stack, specifically `libnftnl` and `libmnl`.

I didn‚Äôt set out to fuzz them.

Originally, I was writing a small, user-facing Nim wrapper around `libnftnl` for another project. I wanted something typed, ergonomic, and pleasant enough to use without constantly reaching for the C headers. As I worked through the API surface and tried to model it faithfully, something else started to stand out.

This wasn‚Äôt just a large or awkward API. It had many of the structural properties that usually make security-relevant code hard to reason about: deeply nested objects, implicit invariants, ownership rules that depend on call order, and a lot of silent normalization happening between representations.

At some point, the work stopped feeling like ‚Äújust‚Äù binding a library and started feeling like I was mapping an attack surface.

I didn‚Äôt have a concrete exploit in mind, and I wasn‚Äôt confident enough in my understanding to make strong claims. But I *was* confident that this was the kind of surface where fuzzing could replace a lot of guesswork with signal.

---
## The fuzzer

Rather than fuzzing this stack by generating arbitrary Netlink packets, I focused on the userland serialization path itself. The goal wasn‚Äôt to bypass validation, but to explore the space of valid-looking structures and iteratively determine where the edges actually were.

That choice let me lean directly on instincts I picked up from years of frontend work. Instead of treating the fuzzer as a black box, I treated it like an interactive system. Something you shape, iterate on, and make pleasant enough to live inside for a long time.

It gave me an excuse to build small DSLs, write automation, and aggressively abstract over sharp edges. Not for elegance‚Äôs sake, but because every bit of friction in the harness showed up immediately as slower exploration.

Before I worried about corpus quality or coverage curves, I spent most of my time trying to make the surface I was fuzzing legible. That work ended up mattering more than any individual heuristic.

### Pretty macros

The first place that legibility really broke down was attribute handling.

`libnftnl` exposes a large family of getters and setters for chain and rule attributes. Each attribute has an expected type, but that expectation is implicit. It lives in documentation, examples, and tribal knowledge rather than in the type system.

Getting it wrong usually doesn‚Äôt fail immediately. You just end up with malformed objects that behave strangely later, often far away from the code that introduced the mistake.

For interactive exploration, that‚Äôs poison. It forces you to keep too much state in your head and turns even small mutations into acts of faith.

I wanted to make those expectations explicit and enforce them mechanically.

In Nim, that turned into a small macro-driven layer that does three things:

- encodes the expected type of each attribute at compile time
- collapses the raw get and set calls into a single interface
- fails early when I try to do something unsupported

I wrote the harness in Nim for very practical reasons. `libnftnl` is a C library with strict ownership rules and a large, loosely-typed surface. Nim‚Äôs ARC/RAII-style memory model and move semantics let me wrap those raw pointers in types that automatically free resources and prevent accidental copies, while still compiling down to straightforward C interop. 

Its compile-time macros then made it possible to encode attribute invariants directly into the type system without adding runtime overhead. I wasn‚Äôt looking for a new ecosystem ‚Äî just a way to make a C API behave more like a memory-safe, structured interface while staying close to the metal.

The goal wasn‚Äôt to make `libnftnl` ‚Äúsafe.‚Äù It was to make it harder for me to lie to myself while experimenting. Nim helped me do that.

What I wanted was something that behaved like a property accessor.

Reading an attribute should look like:

```cpp
chain.name
```

Setting one should look like:

```nim
chain.policy = NF_ACCEPT
```

The core of that mechanism is a small Nim macro. At first glance, the signature is completely opaque.

```nim
macro attrOp*(c: typed,
              attr: enum_nftnl_chain_attr,
              args: varargs[untyped]): untyped =
```

That‚Äôs not accidental. This macro sits right at the boundary between ‚Äúnice‚Äù code and raw C calls.

There are three inputs:

- `c` is the chain object we‚Äôre operating on. It‚Äôs marked `typed` so the macro can inspect its structure and extract the underlying raw pointer it needs to call into `libnftnl`.
    
- `attr` is a compile-time enum constant identifying a specific chain attribute. These enums are generated directly from `libnftnl`‚Äôs headers, so each value corresponds to a fixed attribute ID and an expected value type known at compile time.
    
- `args` is a variable-length list of expressions representing the value we might be setting.
    

The trick is that the _number_ of arguments determines the operation.

```nim
if args.len == 0:
    # getter
elif args.len == 1:
    # setter
else:
    error "attrOp takes 0 or 1 arguments"
```

If no value is provided, the macro expands into a getter.  
If exactly one value is provided, it expands into a setter.  
Anything else is rejected at compile time.

---

### Getter expansion

In the getter case, the macro expands to something equivalent to:

```nim
rawGetAttr[expectedType(attr)](c.raw, attr.uint16)
```

A few important things are happening here:

- `expectedType(attr)` is a compile-time mapping from attribute ‚Üí type.  
    For example, `NFTNL_CHAIN_NAME` maps to `string`, while `NFTNL_CHAIN_POLICY` maps to `uint32`.
    
- That type is used to specialize the underlying getter at compile time.
    
- The enum itself is lowered to the numeric attribute ID (`uint16`) that `libnftnl` expects.

If I try to read an attribute using the wrong type, the code simply doesn‚Äôt compile.

---

### Setter expansion

The setter case expands into a call that looks like this conceptually:

```nim
rawSetAttr(c.raw, attr.uint16, value)
```

The interesting part is how `rawSetAttr` behaves.

Instead of a single monolithic setter, it dispatches _on the Nim type of the value_:

- strings call `nftnl_chain_set_str`
    
- `uint32` calls `nftnl_chain_set_u32`
    
- `uint64` calls `nftnl_chain_set_u64`
    
- enums and other integers are coerced and width-checked before dispatch
    
- anything else fails at compile time

So when I write:

```nim
chain.policy = NF_ACCEPT
```

What I actually get is:

- compile-time validation that `policy` expects a `uint32`
    
- compile-time validation that `NF_ACCEPT` is representable
    
- a concrete call to the correct `libnftnl` setter
    
- zero dynamic checks at runtime

That‚Äôs the entire point of this layer. Not abstraction for its own sake, but collapsing a wide, error-prone surface into something I could reason about _locally_ while fuzzing.

Once this was in place, building and mutating chains stopped feeling like poking at a C API and started feeling like manipulating a data structure.

And that change mattered far more than any individual fuzzing heuristic.

---
## One-click fuzzing

Up to this point, everything I‚Äôve described lives inside the harness itself: the API modeling, the macros, the abstractions that made exploration tractable.

That work mattered, but it wasn‚Äôt enough.

In practice, fuzzing lives or dies on how easy it is to _run_. If starting the fuzzer requires negotiating permissions, SSHing into machines, remembering flags, or cleaning up state by hand, the feedback loop collapses. You stop iterating. You stop exploring. You start procrastinating.

This became very real for me because I wasn‚Äôt fuzzing on my own machine.

A close friend of mine is a very capable operator. He owns and maintains several large servers, understands hardware deeply, and is understandably protective of his systems. He was happy to let me use the hardware, but not at the cost of handing out root, editing systemd units by hand, or running half-baked fuzzing setups directly on a shared host.

That boundary was reasonable, and it ended up being productive.

It forced me to treat the _deployment_ of the fuzzer as part of the system I was designing, not an afterthought.

### Three iterations of automation

I didn‚Äôt get this right on the first try. It took three distinct iterations before the setup stopped fighting me.

**First**, I automated the build itself.  
That meant reproducible builds of the fuzzer, the harness, and coverage-instrumented versions of `libnftnl` and `libmnl`. If I couldn‚Äôt rebuild everything deterministically, nothing else mattered.

**Second**, I automated observability.  
I added Prometheus and Grafana, wired up log parsing and coverage export, and made it possible to see what the fuzzer was doing without SSHing into a box and tailing files. This helped, but it didn‚Äôt solve the biggest problem.

**Third**, the system OOM-killed itself.

Running many libFuzzer workers against a complex userland library is brutal on memory. Even with reasonable limits, the host would eventually hit OOM pressure. At that point, I stopped trying to be clever and changed the shape of the problem entirely.

### Containing the blast radius

Instead of running the fuzzer directly on the host, I moved it into a dedicated microVM.

That one decision unlocked everything else.

Inside the VM, I could:

- hard-cap memory with cgroups
    
- auto-scale the number of fuzzing workers based on available RAM
    
- enable zram to absorb short-lived memory spikes
    
- tune kernel parameters specifically for sanitizer-heavy workloads
    
- crash and restart the entire environment without affecting the host
    

The VM mounts a single shared directory via virtiofs for corpora and logs. That‚Äôs the only bridge. Everything else is isolated.

From my friend‚Äôs perspective, this was suddenly acceptable.  
From my perspective, it was liberating.

### From setup to button

Once the fuzzer lived inside a microVM, the remaining pieces snapped into place quickly.

- One command builds everything.
    
- One command starts observability.
    
- One command launches the VM.
    
- The fuzzer auto-scales, auto-restarts, and never OOMs the host.
    
- Metrics and coverage show up immediately.
    
- Logs stream continuously.
    
- Corpora persist across restarts.
    

There‚Äôs no fragile choreography. No manual cleanup. No ‚Äúdon‚Äôt touch this while it‚Äôs running.‚Äù

I could hand the entire setup to someone else and say: _run this_, without a 30-minute explanation.

That‚Äôs the same bar frontend tooling set years ago, and it‚Äôs still surprisingly rare in fuzzing.

The harness, macros, and VM automation described here live in the project repository:

[`https://github.com/becker63/libnet/`](https://github.com/becker63/libnet/)

---
## Why this mattered

None of this made the fuzzer ‚Äúsmarter.‚Äù

What it did was remove excuses.

When running the fuzzer costs a click instead of a commitment, you experiment more freely. You try things you‚Äôre not sure will work. You re-run after small changes. You let it explore while you think.

That‚Äôs the same dynamic that made frontend work feel fast in the first place. The tooling fades into the background, and what‚Äôs left is a tight loop between intention and observation.

Once I had that loop, fuzzing stopped feeling like a special activity and started feeling like a normal part of development.

That shift mattered more than any individual result.

I want to be explicit about the scope here: I‚Äôm not a traditional security researcher, and this wasn‚Äôt a disciplined vulnerability discovery effort in the academic or professional sense. I didn‚Äôt arrive with a threat model, a target class, or a plan to grind through minimization until a clean exploit fell out.

What I _did_ have was a working mental model of a complicated system, a suspicion that the userland boundary was doing more work than most people assume, and a workflow that let me explore that surface without constantly second-guessing myself.

The fuzzer did generate a non-trivial corpus and exercised parts of `libnftnl` in ways I wouldn‚Äôt have written by hand. Some of that behavior was genuinely surprising. Other parts were messy, ambiguous, or hard to interpret without deeper tooling than I had time to build.

Eventually, the work started to drift away from what I‚Äôm good at, designing systems and feedback loops, and toward the kind of sustained forensic analysis that real security research demands. At that point, I stopped.

That decision was intentional.

What I _do_ have are clearer models: of how `libnftnl` structures its objects in memory, where normalization happens, how userland serialization feeds the kernel boundary, and why that space is interesting at all. I also have a handful of concrete observations and leads that I think are worth following up on‚Äîby people who actually want to do that work.

The next post is about those models.  
Not exploits, not claims, just a closer look at the surface itself, why it‚Äôs shaped the way it is, and why I think it deserves more deliberate attention than it usually gets.
</file>

<file path="hooks/index.ts">
/**
 * Custom React hooks for the blog application
 */

export { useScrollFadeAnimation } from "./useScrollFadeAnimation";
export type { ScrollFadeConfig, ScrollFadeValues } from "./useScrollFadeAnimation";

export { useMobileDetection } from "./useMobileDetection";
</file>

<file path="hooks/useMobileDetection.ts">
"use client";

import { useState, useEffect } from "react";

/**
 * Hook that detects if the viewport is mobile-sized and handles SSR hydration.
 * 
 * @param breakpoint - The max width in pixels considered "mobile" (default: 1024)
 * @returns Object with isMobile and hasMounted booleans
 * 
 * @example
 * ```tsx
 * const { isMobile, hasMounted } = useMobileDetection();
 * 
 * if (!hasMounted) return <SSRFallback />;
 * if (!isMobile) return null; // Don't render on desktop
 * 
 * return <MobileOnlyComponent />;
 * ```
 */
export function useMobileDetection(breakpoint: number = 1024) {
    const [isMobile, setIsMobile] = useState(false);
    const [hasMounted, setHasMounted] = useState(false);

    useEffect(() => {
        setHasMounted(true);

        const checkMobile = () => {
            setIsMobile(window.innerWidth < breakpoint);
        };

        checkMobile();
        window.addEventListener("resize", checkMobile);

        return () => window.removeEventListener("resize", checkMobile);
    }, [breakpoint]);

    return { isMobile, hasMounted };
}
</file>

<file path="hooks/useScrollFadeAnimation.ts">
"use client";

import { useScroll, useTransform, MotionValue } from "framer-motion";
import { LAYOUT } from "../lib/layout";

/**
 * Configuration for scroll-based fade animation
 */
export interface ScrollFadeConfig {
    /** Scroll position where animation starts (default: 0) */
    scrollStart: number;
    /** Scroll position where animation ends (default: 200) */
    scrollEnd: number;
    /** How far the element moves vertically during fade (default: -30) */
    translateY: number;
    /** Starting margin that animates to 0 (default: 12) */
    marginStart: number;
}

/**
 * Return type for the scroll fade animation hook
 */
export interface ScrollFadeValues {
    /** Opacity value from 1 to 0 */
    opacity: MotionValue<number>;
    /** Y translation value */
    y: MotionValue<number>;
    /** Margin bottom value from marginStart to 0 */
    marginBottom: MotionValue<number>;
    /** The scroll Y position */
    scrollY: MotionValue<number>;
}

/**
 * Hook that provides scroll-based fade animation values.
 * Use with framer-motion's motion components for smooth fade-out-on-scroll effects.
 * 
 * @example
 * ```tsx
 * const { opacity, y, marginBottom } = useScrollFadeAnimation();
 * 
 * return (
 *   <motion.div style={{ opacity, y, marginBottom }}>
 *     Content that fades on scroll
 *   </motion.div>
 * );
 * ```
 */
export function useScrollFadeAnimation(config?: Partial<ScrollFadeConfig>): ScrollFadeValues {
    const { scrollY } = useScroll();

    const finalConfig: ScrollFadeConfig = {
        scrollStart: config?.scrollStart ?? LAYOUT.animation.scrollStart,
        scrollEnd: config?.scrollEnd ?? LAYOUT.animation.scrollEnd,
        translateY: config?.translateY ?? LAYOUT.animation.translateY,
        marginStart: config?.marginStart ?? LAYOUT.gap,
    };

    const opacity = useTransform(
        scrollY,
        [finalConfig.scrollStart, finalConfig.scrollEnd],
        [1, 0]
    );

    const y = useTransform(
        scrollY,
        [finalConfig.scrollStart, finalConfig.scrollEnd],
        [0, finalConfig.translateY]
    );

    const marginBottom = useTransform(
        scrollY,
        [finalConfig.scrollStart, finalConfig.scrollEnd],
        [finalConfig.marginStart, 0]
    );

    return { opacity, y, marginBottom, scrollY };
}
</file>

<file path="lib/animationDelay.ts">
// Simple deterministic hash ‚Üí 0‚Äì1 float
export function seededDelay(seed: string, max = 0.6) {
  let hash = 0;
  for (let i = 0; i < seed.length; i++) {
    hash = (hash << 5) - hash + seed.charCodeAt(i);
    hash |= 0;
  }
  const normalized = Math.abs(hash % 1000) / 1000;
  return normalized * max;
}
</file>

<file path="lib/blogs.ts">
import fs from "fs";
import path from "path";
// @ts-ignore
import matter from "gray-matter";

const postsDirectory = path.join(process.cwd(), "content/posts");

export interface BlogPost {
    slug: string;
    meta: {
        title: string;
        date: string;
        description: string;
        tags: string[];
        image?: string;
    };
    content: string;
    text?: string;
    children?: BlogPost[];
}

export function getPostSlugs() {
    if (!fs.existsSync(postsDirectory)) return [];
    return fs.readdirSync(postsDirectory);
}

export function getPostBySlug(slug: string): BlogPost | null {
    const realSlug = slug.replace(/\.mdx$/, "");
    const fullPath = path.join(postsDirectory, `${realSlug}.mdx`);

    if (!fs.existsSync(fullPath)) return null;

    const fileContents = fs.readFileSync(fullPath, "utf8");
    const { data, content } = matter(fileContents);

    return {
        slug: realSlug,
        meta: data as BlogPost["meta"],
        content,
    };
}

export function getAllPosts(): BlogPost[] {
    const slugs = getPostSlugs();
    const posts = slugs
        .map((slug) => getPostBySlug(slug))
        .filter((post): post is BlogPost => post !== null)
        // Sort posts by date in descending order
        .sort((post1, post2) => (post1.meta.date > post2.meta.date ? -1 : 1));
    return posts;
}
</file>

<file path="lib/layout.ts">
/**
 * Centralized layout configuration for the root page.
 * All gaps, spacing, and widths should be defined here.
 *
 * This provides a single source of truth for layout values
 * used across the root page and its components.
 */

// Core spacing values (in pixels)
export const LAYOUT = {
  /** Standard gap between elements (matches panda "layout" token = 12px) */
  gap: 12,

  /** Edge margin from viewport for full-width elements (e.g., navbar) */
  edgeMargin: 12,

  /** Content width as viewport percentage */
  contentWidth: "90vw",

  /** Navbar calculated values */
  navbar: {
    /** Full width minus edge margins on both sides */
    width: "calc(100vw - 24px)", // 100vw - (edgeMargin * 2)
    /** Approximate height of navbar */
    height: 45,
  },

  /** Animation scroll range for navbar fade */
  animation: {
    /** Scroll position where animation starts */
    scrollStart: 20,
    /** Scroll position where animation ends (navbar fully faded) */
    scrollEnd: 70,
    /** How far navbar moves up during fade */
    translateY: -30,
  },
} as const;

// Derived values for CSS calc expressions
export const layoutCalc = {
  /** Total edge margins (both sides) */
  totalEdgeMargins: LAYOUT.edgeMargin * 2,
  /** Navbar width calculated from layout values */
  navbarWidth: `calc(100vw - ${LAYOUT.edgeMargin * 2}px)`,
};

// CSS-ready values for direct use in styles
export const layoutStyles = {
  gap: `${LAYOUT.gap}px`,
  edgeMargin: `${LAYOUT.edgeMargin}px`,
  contentWidth: LAYOUT.contentWidth,
  navbarWidth: layoutCalc.navbarWidth,
};

/** Panda token name for use with css({ gap: LAYOUT_GAP }) */
export const LAYOUT_GAP = "layout";
</file>

<file path="tests/utils/gap-utils.ts">
/**
 * Shared gap detection utilities for Playwright tests.
 * Provides consistent gap analysis across all pages.
 */

import { Page } from '@playwright/test';

/** Expected gap between cards (matches panda spacing.layout = 12px) */
export const EXPECTED_GAP = 12;

/** Tolerance for sub-pixel rendering differences */
export const GAP_TOLERANCE = 2;

/** Standard port for dev server */
export const PORT = 3000;

/** Base URL for tests */
export const BASE_URL = `http://localhost:${PORT}`;

/** Standard viewport configurations */
export const VIEWPORTS = {
    mobile: { width: 375, height: 812 },
    tablet: { width: 768, height: 1024 },
    desktop: { width: 1024, height: 768 },
    desktopLarge: { width: 1280, height: 800 },
} as const;

export type ViewportName = keyof typeof VIEWPORTS;

/** Card detection result */
export interface CardInfo {
    rect: {
        top: number;
        bottom: number;
        left: number;
        right: number;
        width: number;
        height: number;
    };
    isNavbar: boolean;
    classList: string[];
}

/** Gap measurement between two cards */
export interface GapInfo {
    gap: number;
    between: string;
    card1Classes: string[];
    card2Classes: string[];
}

/** Full gap analysis result */
export interface GapAnalysis {
    pageUrl: string;
    viewport: { width: number; height: number };
    totalCards: number;
    gaps: GapInfo[];
    uniqueGaps: number[];
    mostCommonGap: number | null;
    inconsistentGaps: GapInfo[];
    isConsistent: boolean;
}

/**
 * Analyze gaps between card elements on a page.
 * Cards are identified by borderRadius: 10px and black background.
 */
export async function analyzeGaps(page: Page): Promise<GapAnalysis> {
    const viewport = page.viewportSize() || { width: 0, height: 0 };
    const pageUrl = page.url();

    const analysis = await page.evaluate((expectedGap) => {
        const allElements = document.querySelectorAll('*');
        const cards: { rect: DOMRect; isNavbar: boolean; classList: string[] }[] = [];

        allElements.forEach(el => {
            const style = window.getComputedStyle(el);
            const isCard = style.borderRadius === '10px' &&
                (style.backgroundColor === 'rgb(0, 0, 0)' || style.backgroundColor === 'rgba(0, 0, 0, 1)');

            if (isCard) {
                const rect = el.getBoundingClientRect();
                // Filter out very small elements
                if (rect.width > 50 && rect.height > 30) {
                    const classList = [...el.classList];
                    const isNavbar = classList.some(c =>
                        c.includes('navbar') || c.includes('layerStyle_navbar')
                    );
                    cards.push({ rect, isNavbar, classList });
                }
            }
        });

        // Sort by vertical position
        cards.sort((a, b) => a.rect.top - b.rect.top);

        // Calculate gaps between vertically adjacent cards
        const gaps: { gap: number; between: string; card1Classes: string[]; card2Classes: string[] }[] = [];
        for (let i = 0; i < cards.length - 1; i++) {
            const current = cards[i];
            const next = cards[i + 1];

            // Skip navbar comparisons
            if (current.isNavbar || next.isNavbar) continue;

            // Check for horizontal overlap (cards must be in same column)
            const horizontalOverlap = !(current.rect.right < next.rect.left || next.rect.right < current.rect.left);

            if (horizontalOverlap && next.rect.top > current.rect.bottom) {
                gaps.push({
                    gap: Math.round(next.rect.top - current.rect.bottom),
                    between: `card ${i} ‚Üí card ${i + 1}`,
                    card1Classes: current.classList,
                    card2Classes: next.classList,
                });
            }
        }

        // Analyze gap consistency
        const gapValues = gaps.map(g => g.gap);
        const uniqueGaps = [...new Set(gapValues)];

        // Find most common gap
        let mostCommonGap: number | null = null;
        if (gapValues.length > 0) {
            const frequency: Record<number, number> = {};
            gapValues.forEach(g => {
                frequency[g] = (frequency[g] || 0) + 1;
            });
            let maxFreq = 0;
            for (const [gap, freq] of Object.entries(frequency)) {
                if (freq > maxFreq) {
                    maxFreq = freq;
                    mostCommonGap = parseInt(gap);
                }
            }
        }

        // Find inconsistent gaps (more than 2px from expected)
        const inconsistentGaps = gaps.filter(g =>
            Math.abs(g.gap - expectedGap) > 2
        );

        return {
            totalCards: cards.length,
            gaps,
            uniqueGaps,
            mostCommonGap,
            inconsistentGaps,
            isConsistent: inconsistentGaps.length === 0,
        };
    }, EXPECTED_GAP);

    return {
        pageUrl,
        viewport,
        ...analysis,
    };
}

/**
 * Log gap analysis results to console.
 */
export function logGapAnalysis(analysis: GapAnalysis): void {
    console.log(`\n--- Gap Analysis: ${analysis.pageUrl} @ ${analysis.viewport.width}x${analysis.viewport.height} ---`);
    console.log(`Cards found: ${analysis.totalCards}`);
    console.log(`Gaps measured: ${analysis.gaps.length}`);
    console.log(`Gap values: ${JSON.stringify(analysis.gaps.map(g => g.gap))}`);
    console.log(`Unique gaps: ${JSON.stringify(analysis.uniqueGaps)}`);
    console.log(`Most common gap: ${analysis.mostCommonGap}px`);
    console.log(`Expected gap: ${EXPECTED_GAP}px (¬±${GAP_TOLERANCE}px tolerance)`);

    if (analysis.isConsistent) {
        console.log(`‚úÖ All gaps consistent`);
    } else {
        console.log(`‚ùå Inconsistent gaps found:`);
        analysis.inconsistentGaps.forEach(g => {
            console.log(`  - ${g.between}: ${g.gap}px (expected ~${EXPECTED_GAP}px)`);
        });
    }
}

/**
 * Get a blog slug for testing /Blogs/[slug] pages.
 */
export async function getFirstBlogSlug(page: Page): Promise<string | null> {
    await page.goto(`${BASE_URL}/Search`);
    await page.waitForTimeout(1000);

    const slug = await page.evaluate(() => {
        const link = document.querySelector('a[href*="/Blogs/"]');
        if (link) {
            const href = link.getAttribute('href');
            if (href) {
                const match = href.match(/\/Blogs\/([^/]+)/);
                return match ? match[1] : null;
            }
        }
        return null;
    });

    return slug;
}
</file>

<file path="tests/gap-consistency.spec.ts">
/**
 * Comprehensive Gap Consistency Tests
 *
 * Tests gap consistency across all pages at multiple viewports.
 * Uses the shared gap-utils for consistent detection.
 *
 * Expected gap: 12px (from panda.config.ts spacing.layout token)
 */

import { test, expect } from '@playwright/test';
import {
    analyzeGaps,
    logGapAnalysis,
    getFirstBlogSlug,
    VIEWPORTS,
    BASE_URL,
    EXPECTED_GAP,
    ViewportName,
} from './utils/gap-utils';

// Test configuration
const TEST_TIMEOUT = 30000;
const LOAD_WAIT = 1500;

// Viewports to test for each page
const TEST_VIEWPORTS: ViewportName[] = ['mobile', 'tablet', 'desktop', 'desktopLarge'];

// Pages to test
const PAGES = [
    { name: 'Root', path: '/' },
    { name: 'Search', path: '/Search' },
];

// ============================================================================
// ROOT PAGE TESTS
// ============================================================================

test.describe('Root Page Gap Consistency', () => {
    for (const viewportName of TEST_VIEWPORTS) {
        const viewport = VIEWPORTS[viewportName];

        test(`gaps should be consistent at ${viewportName} (${viewport.width}x${viewport.height})`, async ({ page }) => {
            test.setTimeout(TEST_TIMEOUT);

            await page.setViewportSize(viewport);
            await page.goto(`${BASE_URL}/`);
            await page.waitForTimeout(LOAD_WAIT);

            const analysis = await analyzeGaps(page);
            logGapAnalysis(analysis);

            // Verify gaps are consistent
            expect(
                analysis.isConsistent,
                `Root page has inconsistent gaps at ${viewportName}: ${JSON.stringify(analysis.inconsistentGaps)}`
            ).toBe(true);

            // Verify most common gap is close to expected (12px)
            if (analysis.mostCommonGap !== null) {
                expect(
                    Math.abs(analysis.mostCommonGap - EXPECTED_GAP),
                    `Root page gap (${analysis.mostCommonGap}px) deviates from expected (${EXPECTED_GAP}px)`
                ).toBeLessThanOrEqual(2);
            }
        });
    }
});

// ============================================================================
// SEARCH PAGE TESTS
// ============================================================================

test.describe('Search Page Gap Consistency', () => {
    for (const viewportName of TEST_VIEWPORTS) {
        const viewport = VIEWPORTS[viewportName];

        test(`gaps should be consistent at ${viewportName} (${viewport.width}x${viewport.height})`, async ({ page }) => {
            test.setTimeout(TEST_TIMEOUT);

            await page.setViewportSize(viewport);
            await page.goto(`${BASE_URL}/Search`);
            await page.waitForTimeout(LOAD_WAIT);

            const analysis = await analyzeGaps(page);
            logGapAnalysis(analysis);

            // Search page may have different gap semantics (blog cards have mb:5)
            // So we check for consistency among detected gaps
            if (analysis.gaps.length > 1) {
                expect(
                    analysis.isConsistent,
                    `Search page has inconsistent gaps at ${viewportName}: ${JSON.stringify(analysis.inconsistentGaps)}`
                ).toBe(true);
            } else {
                console.log(`Only ${analysis.gaps.length} gap(s) found on Search page - skipping consistency check`);
            }
        });
    }
});

// ============================================================================
// BLOG PAGE TESTS
// ============================================================================

test.describe('Blog Page Gap Consistency', () => {
    let blogSlug: string | null = null;

    test.beforeAll(async ({ browser }) => {
        // Get a valid blog slug before running tests
        const page = await browser.newPage();
        blogSlug = await getFirstBlogSlug(page);
        await page.close();

        if (!blogSlug) {
            console.log('‚ö†Ô∏è No blog posts found - blog page tests will be skipped');
        }
    });

    for (const viewportName of TEST_VIEWPORTS) {
        const viewport = VIEWPORTS[viewportName];

        test(`gaps should be consistent at ${viewportName} (${viewport.width}x${viewport.height})`, async ({ page }) => {
            test.setTimeout(TEST_TIMEOUT);

            // Skip if no blog posts available
            test.skip(!blogSlug, 'No blog posts available for testing');

            await page.setViewportSize(viewport);
            await page.goto(`${BASE_URL}/Blogs/${blogSlug}`);
            await page.waitForTimeout(LOAD_WAIT);

            const analysis = await analyzeGaps(page);
            logGapAnalysis(analysis);

            // Blog pages typically have a single card with content
            // Check that any gaps found are consistent
            if (analysis.gaps.length > 0) {
                expect(
                    analysis.isConsistent,
                    `Blog page has inconsistent gaps at ${viewportName}: ${JSON.stringify(analysis.inconsistentGaps)}`
                ).toBe(true);
            } else {
                console.log(`No gaps between cards on Blog page at ${viewportName} - expected for single-card layout`);
            }
        });
    }
});

// ============================================================================
// CROSS-PAGE CONSISTENCY TEST
// ============================================================================

test.describe('Cross-Page Gap Consistency', () => {
    test('all pages should use the same base gap value', async ({ page }) => {
        test.setTimeout(60000);

        const gapsBySite: { page: string; gaps: number[] }[] = [];

        // Test root page at desktop
        await page.setViewportSize(VIEWPORTS.desktopLarge);
        await page.goto(`${BASE_URL}/`);
        await page.waitForTimeout(LOAD_WAIT);
        const rootAnalysis = await analyzeGaps(page);
        gapsBySite.push({ page: 'Root', gaps: rootAnalysis.gaps.map(g => g.gap) });

        // Test Search page
        await page.goto(`${BASE_URL}/Search`);
        await page.waitForTimeout(LOAD_WAIT);
        const searchAnalysis = await analyzeGaps(page);
        gapsBySite.push({ page: 'Search', gaps: searchAnalysis.gaps.map(g => g.gap) });

        // Log results
        console.log('\n=== Cross-Page Gap Summary ===');
        gapsBySite.forEach(({ page, gaps }) => {
            console.log(`${page}: ${gaps.length > 0 ? gaps.join(', ') + 'px' : 'no gaps detected'}`);
        });

        // All detected gaps should be close to 12px (the layout token)
        for (const { page: pageName, gaps } of gapsBySite) {
            for (const gap of gaps) {
                expect(
                    Math.abs(gap - EXPECTED_GAP),
                    `${pageName} has gap ${gap}px, expected ~${EXPECTED_GAP}px`
                ).toBeLessThanOrEqual(2);
            }
        }
    });
});
</file>

<file path="tests/layout.spec.ts">
import { test, expect } from '@playwright/test';

test('homepage layouts correctly with no overflow', async ({ page }) => {
    test.setTimeout(60000);
    await page.setViewportSize({ width: 1920, height: 1080 });
    // Go to homepage
    await page.goto('http://localhost:3000');

    // Wait for settlement
    await page.waitForTimeout(2000);

    // Overflow detection with different rules for horizontal vs vertical:
    // - HORIZONTAL: Always fail. Images should scale, never clip horizontally.
    // - VERTICAL: Skip if element is clipped by ancestor with overflow:hidden (acceptable for scrollable areas)
    const overflowIssues = await page.evaluate(() => {
        const issues: { type: string; element: string; value: number; viewport: number; classList: string[]; clipped?: boolean }[] = [];

        // Helper: check if element is vertically clipped by ancestor with overflow:hidden
        const isVerticallyClippedByAncestor = (el: Element): boolean => {
            let current: Element | null = el.parentElement;
            while (current) {
                const style = window.getComputedStyle(current);
                if (style.overflow === 'hidden' || style.overflowY === 'hidden') {
                    const ancestorRect = current.getBoundingClientRect();
                    const elRect = el.getBoundingClientRect();
                    if (elRect.bottom > ancestorRect.bottom) {
                        return true; // Element is vertically clipped
                    }
                }
                current = current.parentElement;
            }
            return false;
        };

        // Helper: check if element is horizontally clipped by ancestor
        const isHorizontallyClippedByAncestor = (el: Element): boolean => {
            let current: Element | null = el.parentElement;
            while (current) {
                const style = window.getComputedStyle(current);
                if (style.overflow === 'hidden' || style.overflowX === 'hidden') {
                    const ancestorRect = current.getBoundingClientRect();
                    const elRect = el.getBoundingClientRect();
                    if (elRect.right > ancestorRect.right) {
                        return true; // Element is horizontally clipped
                    }
                }
                current = current.parentElement;
            }
            return false;
        };

        document.querySelectorAll('*').forEach(el => {
            const rect = el.getBoundingClientRect();

            // HORIZONTAL OVERFLOW: Always report, even if clipped (clipping is a bug for horizontal)
            if (rect.right > window.innerWidth + 1) {
                const isClipped = isHorizontallyClippedByAncestor(el);
                issues.push({
                    type: isClipped ? "horizontal-clipped" : "horizontal-overflow",
                    element: el.tagName,
                    value: rect.right,
                    viewport: window.innerWidth,
                    classList: [...el.classList],
                    clipped: isClipped
                });
            }

            // VERTICAL OVERFLOW: Skip if clipped (acceptable for scrollable content)
            if (rect.bottom > window.innerHeight + 1) {
                if (!isVerticallyClippedByAncestor(el)) {
                    issues.push({
                        type: "vertical-overflow",
                        element: el.tagName,
                        value: rect.bottom,
                        viewport: window.innerHeight,
                        classList: [...el.classList]
                    });
                }
            }
        });

        return issues;
    });

    console.log("--- OVERFLOW DIAGNOSTICS ---");
    if (overflowIssues.length === 0) {
        console.log("No overflow detected. Layout is correct.");
    } else {
        console.log("Overflow Issues Found:");
        console.log(JSON.stringify(overflowIssues, null, 2));
    }
    console.log("----------------------------");

    expect(overflowIssues.length).toBe(0);
});
</file>

<file path="tests/mobile-navbar.spec.ts">
import { test, expect } from '@playwright/test';

/**
 * Mobile Navbar Animation Test
 * 
 * Focused test for verifying mobile navbar behavior:
 * 1. Width consistency - navbar should maintain same width while animating
 * 2. Gap consistency - gap between navbar and content should match gaps between other items
 * 3. No z-overlap with content
 */

const PORT = 3000; // Use current dev server port

test.describe('Mobile Navbar Animation', () => {
    test('navbar maintains width, gap, and no overlap on mobile', async ({ page }) => {
        test.setTimeout(30000);

        await page.setViewportSize({ width: 375, height: 812 });
        await page.goto(`http://localhost:${PORT}`);
        await page.waitForTimeout(2000);

        // === TEST 1: Width Consistency ===
        const initialState = await page.evaluate(() => {
            const navbarText = Array.from(document.querySelectorAll('span')).find(
                el => el.textContent?.includes('becker63')
            );
            if (!navbarText) return null;

            // Find the navbar's animated container (the motion.div with 90vw width)
            let navbarContainer: Element | null = navbarText;
            while (navbarContainer && navbarContainer.parentElement) {
                navbarContainer = navbarContainer.parentElement;
                const style = window.getComputedStyle(navbarContainer);
                // Look for the container that has the 90vw width
                if (style.width && parseFloat(style.width) > 200) {
                    break;
                }
            }

            const rect = navbarContainer?.getBoundingClientRect();
            return {
                width: Math.round(rect?.width || 0),
                bottom: Math.round(rect?.bottom || 0),
            };
        });

        console.log('Initial navbar state:', initialState);
        expect(initialState, 'Navbar not found').not.toBeNull();
        const initialWidth = initialState!.width;

        // === TEST 2: Gap Consistency (before scroll) ===
        const gapAnalysis = await page.evaluate(() => {
            // Find navbar bottom
            const navbarText = Array.from(document.querySelectorAll('span')).find(
                el => el.textContent?.includes('becker63')
            );
            if (!navbarText) return { error: 'Navbar not found' };

            let navbarContainer: Element | null = navbarText;
            while (navbarContainer && navbarContainer.parentElement) {
                navbarContainer = navbarContainer.parentElement;
                const style = window.getComputedStyle(navbarContainer);
                if (style.width && parseFloat(style.width) > 200) {
                    break;
                }
            }

            const navbarRect = navbarContainer?.getBoundingClientRect();
            if (!navbarRect) return { error: 'Navbar container not found' };

            // Find content cards (black boxes with border-radius)
            const cards: { rect: DOMRect }[] = [];
            document.querySelectorAll('div').forEach(el => {
                const style = window.getComputedStyle(el);
                const isCard = style.borderRadius === '10px' &&
                    (style.backgroundColor === 'rgb(0, 0, 0)' || style.backgroundColor === 'rgba(0, 0, 0, 1)');

                if (isCard) {
                    const rect = el.getBoundingClientRect();
                    if (rect.width > 50 && rect.height > 30) {
                        cards.push({ rect });
                    }
                }
            });

            cards.sort((a, b) => a.rect.top - b.rect.top);

            const firstCard = cards[0];
            if (!firstCard) return { error: 'No content cards found' };

            // Gap between navbar and first content
            const navbarToContentGap = Math.round(firstCard.rect.top - navbarRect.bottom);

            // Gaps between content cards
            const contentGaps: number[] = [];
            for (let i = 0; i < cards.length - 1; i++) {
                const current = cards[i];
                const next = cards[i + 1];
                const horizontalOverlap = !(current.rect.right < next.rect.left || next.rect.right < current.rect.left);
                if (horizontalOverlap && next.rect.top > current.rect.bottom) {
                    contentGaps.push(Math.round(next.rect.top - current.rect.bottom));
                }
            }

            const expectedGap = contentGaps.length > 0 ? contentGaps[0] : 12; // Default to layout token (12px)

            return {
                navbarToContentGap,
                contentGaps,
                expectedGap,
                gapDifference: Math.abs(navbarToContentGap - expectedGap),
                hasOverlap: navbarToContentGap < 0
            };
        });

        console.log('Gap analysis:', gapAnalysis);

        if ('error' in gapAnalysis) {
            throw new Error(gapAnalysis.error);
        }

        // Check no overlap
        expect(gapAnalysis.hasOverlap, 'Navbar overlaps with content').toBe(false);

        // Check gap consistency - navbar may have different margins than content
        // Allow more tolerance since navbar uses edge margins while content uses centered 90vw
        expect(
            gapAnalysis.gapDifference,
            `Navbar gap (${gapAnalysis.navbarToContentGap}px) differs from content gaps (${gapAnalysis.expectedGap}px)`
        ).toBeLessThanOrEqual(8);

        // === TEST 3: Width Consistency During Scroll ===
        await page.evaluate(() => window.scrollBy(0, 100));
        await page.waitForTimeout(300);

        const midScrollState = await page.evaluate(() => {
            const navbarText = Array.from(document.querySelectorAll('span')).find(
                el => el.textContent?.includes('becker63')
            );
            if (!navbarText) return null;

            let navbarContainer: Element | null = navbarText;
            while (navbarContainer && navbarContainer.parentElement) {
                navbarContainer = navbarContainer.parentElement;
                const style = window.getComputedStyle(navbarContainer);
                if (style.width && parseFloat(style.width) > 200) {
                    break;
                }
            }

            const rect = navbarContainer?.getBoundingClientRect();
            return {
                width: Math.round(rect?.width || 0),
            };
        });

        console.log('Mid-scroll navbar state:', midScrollState);
        expect(midScrollState, 'Navbar not found after scroll').not.toBeNull();

        const widthDiff = Math.abs(initialWidth - midScrollState!.width);
        expect(
            widthDiff,
            `Navbar width changed from ${initialWidth}px to ${midScrollState!.width}px during scroll`
        ).toBeLessThanOrEqual(2);

        console.log('‚úÖ All navbar animation tests passed');
    });
});
</file>

<file path="tests/navbar-overlap.spec.ts">
import { test, expect } from "@playwright/test";

/**
 * Test that verifies the mobile navbar doesn't overlap with content below it.
 * The navbar should be positioned above the content grid, not overlapping.
 */
test.describe("Mobile Navbar Positioning", () => {
  // Mobile resolutions to test
  const mobileViewports = [
    { width: 375, height: 812, name: "iPhone X" },
    { width: 390, height: 844, name: "iPhone 12" },
    { width: 414, height: 896, name: "iPhone XR" },
    { width: 360, height: 740, name: "Galaxy S8" },
  ];

  for (const viewport of mobileViewports) {
    test(`navbar does not overlap content on ${viewport.name} (${viewport.width}x${viewport.height})`, async ({
      page,
    }) => {
      test.setTimeout(30000);

      await page.setViewportSize({
        width: viewport.width,
        height: viewport.height,
      });
      await page.goto("http://localhost:3000");

      // Wait for page to fully load and hydrate
      await page.waitForTimeout(2000);

      // Detect z-overlap: check if navbar overlaps with content elements
      const overlapResult = await page.evaluate(() => {
        // Find the navbar - it contains "becker63" text
        const navbarText = Array.from(document.querySelectorAll("span")).find(
          (el) => el.textContent?.includes("becker63"),
        );

        if (!navbarText) {
          return { error: "Navbar text not found" };
        }

        // Get the navbar container (traverse up to find nav or containing div)
        let navbar: Element | null = navbarText;
        while (navbar && navbar.tagName !== "NAV" && navbar.parentElement) {
          navbar = navbar.parentElement;
          // Stop at a reasonable container level
          if (navbar.classList.length > 0 || navbar.tagName === "NAV") {
            break;
          }
        }

        const navbarRect = navbar.getBoundingClientRect();

        // Find content elements that should be BELOW the navbar
        // These are the main content cards (black rounded boxes)
        const contentElements = Array.from(
          document.querySelectorAll("div"),
        ).filter((el) => {
          const style = window.getComputedStyle(el);
          // Looking for content cards with background and border-radius
          return (
            style.backgroundColor === "rgb(0, 0, 0)" &&
            style.borderRadius !== "0px" &&
            el.getBoundingClientRect().height > 50
          );
        });

        const overlaps: Array<{
          navbarBottom: number;
          contentTop: number;
          overlap: number;
          contentClasses: string[];
        }> = [];

        for (const content of contentElements) {
          const contentRect = content.getBoundingClientRect();

          // Check if navbar bottom extends into content top
          // Allow 2px tolerance for rendering differences
          if (navbarRect.bottom > contentRect.top + 2) {
            overlaps.push({
              navbarBottom: Math.round(navbarRect.bottom),
              contentTop: Math.round(contentRect.top),
              overlap: Math.round(navbarRect.bottom - contentRect.top),
              contentClasses: [...content.classList],
            });
          }
        }

        return {
          navbarRect: {
            top: Math.round(navbarRect.top),
            bottom: Math.round(navbarRect.bottom),
            height: Math.round(navbarRect.height),
          },
          overlaps,
          contentElementsFound: contentElements.length,
        };
      });

      console.log(`--- ${viewport.name} NAVBAR OVERLAP TEST ---`);
      console.log(JSON.stringify(overlapResult, null, 2));
      console.log("----------------------------------------");

      // Fail if we detected overlaps
      if ("error" in overlapResult) {
        throw new Error(overlapResult.error);
      }

      expect(
        overlapResult.overlaps.length,
        `Navbar overlaps with ${overlapResult.overlaps.length} content elements`,
      ).toBe(0);
    });
  }

  test("navbar fades out and content shifts up on scroll", async ({ page }) => {
    test.setTimeout(30000);

    await page.setViewportSize({ width: 375, height: 812 });
    await page.goto("http://localhost:3000");
    await page.waitForTimeout(2000);

    // Get initial navbar opacity and position
    const initialState = await page.evaluate(() => {
      const navbarText = Array.from(document.querySelectorAll("span")).find(
        (el) => el.textContent?.includes("becker63"),
      );
      if (!navbarText) return null;

      let navbar: Element | null = navbarText;
      while (navbar && navbar.parentElement) {
        const style = window.getComputedStyle(navbar);
        if (style.opacity !== "1" || navbar.tagName === "NAV") {
          break;
        }
        navbar = navbar.parentElement;
      }

      const style = window.getComputedStyle(navbar!);
      return {
        opacity: parseFloat(style.opacity),
        top: navbar!.getBoundingClientRect().top,
      };
    });

    console.log("Initial state:", initialState);
    expect(initialState).not.toBeNull();
    // Navbar may have 0.7 opacity from layerStyle, check it's visible
    expect(initialState!.opacity).toBeGreaterThan(0.5);

    // Scroll down 250px (animation range is now 0-200)
    await page.evaluate(() => window.scrollBy(0, 250));
    await page.waitForTimeout(500);

    // Check navbar state after scroll
    const scrolledState = await page.evaluate(() => {
      const navbarText = Array.from(document.querySelectorAll("span")).find(
        (el) => el.textContent?.includes("becker63"),
      );
      if (!navbarText) return null;

      let navbar: Element | null = navbarText;
      while (navbar && navbar.parentElement) {
        const style = window.getComputedStyle(navbar);
        // Find the animated container (look for transform or opacity changes)
        if (style.opacity !== "1" || navbar.tagName === "NAV") {
          break;
        }
        navbar = navbar.parentElement;
      }

      const style = window.getComputedStyle(navbar!);
      return {
        opacity: parseFloat(style.opacity),
        top: navbar!.getBoundingClientRect().top,
      };
    });

    console.log("Scrolled state:", scrolledState);
    expect(scrolledState).not.toBeNull();
    // After scrolling 250px, navbar should be faded out (opacity near 0)
    expect(scrolledState!.opacity).toBeLessThan(0.8);
  });
});
</file>

<file path="tests/svg-visibility.spec.ts">
import { test, expect } from '@playwright/test';

test('SVG visibility across viewport sizes', async ({ page }) => {
    test.setTimeout(120000);

    // Navigate to homepage
    await page.goto('http://localhost:3000');
    await page.waitForTimeout(2000);

    // Test viewport widths from desktop down to mobile
    const testWidths = [
        1920, 1440, 1280, 1024,  // Desktop
        1023, 1000, 900, 800,    // Tablet/transition
        768, 700, 600, 500,     // Mobile breakpoints
        400, 360, 320           // Small mobile
    ];

    const results: { width: number; bebopVisible: boolean; bebopInfo: any }[] = [];

    for (const width of testWidths) {
        await page.setViewportSize({ width, height: 768 });
        await page.waitForTimeout(500); // Allow layout to settle

        // Look specifically for the Bebop SVG (react-inlinesvg output)
        // It should be a large SVG with a viewBox of "0 0 1042 1066"
        const bebopInfo = await page.evaluate(() => {
            // Find all SVGs
            const allSvgs = document.querySelectorAll('svg');

            for (const svg of allSvgs) {
                const rect = svg.getBoundingClientRect();
                const viewBox = svg.getAttribute('viewBox');
                const style = window.getComputedStyle(svg);

                // Bebop SVG should have the specific viewBox or be reasonably large
                const isBebop = viewBox === '0 0 1042 1066' ||
                    (rect.width > 50 && rect.height > 50);

                if (isBebop && rect.width > 0 && rect.height > 0) {
                    return {
                        found: true,
                        visible: true,
                        viewBox,
                        rect: { width: rect.width, height: rect.height, top: rect.top, left: rect.left },
                        display: style.display,
                        visibility: style.visibility
                    };
                }
            }

            // Check if Bebop container exists even if SVG is 0x0
            const allSvgsInfo: any[] = [];
            allSvgs.forEach(svg => {
                const rect = svg.getBoundingClientRect();
                allSvgsInfo.push({
                    viewBox: svg.getAttribute('viewBox'),
                    width: rect.width,
                    height: rect.height,
                    classList: [...svg.classList]
                });
            });

            return { found: false, visible: false, allSvgs: allSvgsInfo };
        });

        const isVisible = bebopInfo.found && bebopInfo.visible;
        results.push({ width, bebopVisible: isVisible, bebopInfo });

        console.log(`Viewport ${width}px: Bebop ${isVisible ? '‚úì VISIBLE' : '‚úó HIDDEN'}`, JSON.stringify(bebopInfo));
    }

    // Find the breakpoint where Bebop disappears
    let lastVisibleWidth = 0;
    let firstHiddenWidth = 0;

    for (let i = 0; i < results.length; i++) {
        if (results[i].bebopVisible) {
            lastVisibleWidth = results[i].width;
        } else if (lastVisibleWidth > 0 && firstHiddenWidth === 0) {
            firstHiddenWidth = results[i].width;
        }
    }

    console.log('--- BREAKPOINT ANALYSIS ---');
    console.log(`Bebop visible at: ${lastVisibleWidth}px`);
    console.log(`Bebop hidden at: ${firstHiddenWidth}px`);
    console.log(`Breakpoint is between ${firstHiddenWidth}px and ${lastVisibleWidth}px`);
    console.log('---------------------------');

    // The test reports the breakpoint
});

test('Bebop SVG should be visible at all viewports', async ({ page }) => {
    test.setTimeout(60000);

    await page.goto('http://localhost:3000');
    await page.waitForTimeout(2000);

    // Test both desktop and mobile viewports
    const testWidths = [
        { width: 1920, name: 'desktop-1920' },
        { width: 1024, name: 'desktop-1024' },
        { width: 768, name: 'tablet' },
        { width: 375, name: 'mobile' }
    ];

    for (const { width, name } of testWidths) {
        await page.setViewportSize({ width, height: 768 });
        await page.waitForTimeout(500);

        const bebopVisible = await page.evaluate(() => {
            const allSvgs = document.querySelectorAll('svg');
            for (const svg of allSvgs) {
                const rect = svg.getBoundingClientRect();
                const viewBox = svg.getAttribute('viewBox');

                // Bebop should have viewBox or be large
                if ((viewBox === '0 0 1042 1066' || rect.width > 50) &&
                    rect.width > 0 && rect.height > 0) {
                    return true;
                }
            }
            return false;
        });

        console.log(`[${name}] ${width}px: Bebop ${bebopVisible ? '‚úì VISIBLE' : '‚úó HIDDEN'}`);
        expect(bebopVisible, `Bebop SVG should be visible at ${width}px (${name})`).toBe(true);
    }
});
</file>

<file path="tests/tree-line-continuity.spec.ts">
import { test, expect } from '@playwright/test';

/**
 * Test that tree lines connecting blog cards render continuously
 * with no gaps between cards at all viewport sizes.
 */

const viewports = [
    { name: 'mobile', width: 375, height: 812 },
    { name: 'tablet', width: 768, height: 1024 },
    { name: 'desktop', width: 1280, height: 800 },
    { name: 'desktopLarge', width: 1920, height: 1080 },
];

test.describe('Tree Line Continuity', () => {
    for (const viewport of viewports) {
        test(`tree lines connect without gaps at ${viewport.name} (${viewport.width}x${viewport.height})`, async ({ page }) => {
            await page.setViewportSize({ width: viewport.width, height: viewport.height });
            await page.goto('http://localhost:3000/Search');
            await page.waitForLoadState('networkidle');

            // Find blog cards by looking for links to /Blogs/
            const blogLinks = await page.locator('a[href^="/Blogs/"]').all();
            const cardCount = blogLinks.length;

            console.log(`\n--- Tree Line Analysis at ${viewport.name} ---`);
            console.log(`Blog cards found: ${cardCount}`);

            if (cardCount < 2) {
                console.log(`Only ${cardCount} cards found - skipping gap test`);
                return;
            }

            // Get all vertical line segments (1px wide white elements)
            const verticalLines = await page.evaluate(() => {
                const elements: { top: number; bottom: number; left: number; height: number }[] = [];

                document.querySelectorAll('div').forEach((el) => {
                    const style = window.getComputedStyle(el);
                    const rect = el.getBoundingClientRect();

                    // Look for thin vertical line elements (1px wide, reasonably tall, white/visible)
                    if (
                        rect.width >= 0.5 && rect.width <= 2 &&
                        rect.height > 20 &&
                        (style.backgroundColor === 'rgb(255, 255, 255)' ||
                            style.backgroundColor === 'white' ||
                            style.background.includes('white') ||
                            style.background.includes('rgb(255, 255, 255)'))
                    ) {
                        elements.push({
                            top: Math.round(rect.top),
                            bottom: Math.round(rect.bottom),
                            left: Math.round(rect.left),
                            height: Math.round(rect.height),
                        });
                    }
                });

                return elements;
            });

            console.log(`Vertical line segments found: ${verticalLines.length}`);

            if (verticalLines.length === 0) {
                // If no lines found via computed style, try to find them by checking styled divs
                console.log('No vertical lines detected via computed style - checking if tree lines exist in DOM');

                // Take screenshot to verify visually
                await page.screenshot({ path: `test-results/tree-lines-${viewport.name}.png` });
                console.log(`Screenshot saved to test-results/tree-lines-${viewport.name}.png`);
                return;
            }

            // Group lines by their left position (same vertical column)
            const linesByColumn = new Map<number, typeof verticalLines>();
            for (const line of verticalLines) {
                // Use a tolerance of 5px for grouping lines in same column
                let foundColumn = false;
                for (const [key, _] of linesByColumn) {
                    if (Math.abs(key - line.left) < 5) {
                        linesByColumn.get(key)!.push(line);
                        foundColumn = true;
                        break;
                    }
                }
                if (!foundColumn) {
                    linesByColumn.set(line.left, [line]);
                }
            }

            console.log(`Distinct line columns: ${linesByColumn.size}`);

            // For each column, verify lines connect without significant gaps
            let gapsFound = 0;
            for (const [left, lines] of linesByColumn) {
                // Sort by vertical position
                lines.sort((a, b) => a.top - b.top);

                // Check for gaps between consecutive segments
                for (let i = 0; i < lines.length - 1; i++) {
                    const current = lines[i];
                    const next = lines[i + 1];
                    const gap = next.top - current.bottom;

                    // Allow tolerance for subpixel rendering and small layout variations
                    const tolerance = 3;

                    if (gap > tolerance) {
                        gapsFound++;
                        console.log(`‚ö†Ô∏è Gap of ${gap}px at column ${left} (line ${i} to ${i + 1})`);
                    }
                }
            }

            // Expect no gaps or report them
            expect(gapsFound, `Found ${gapsFound} gaps in tree lines`).toBe(0);
            console.log('‚úÖ Tree lines are continuous with no gaps');
        });
    }
});
</file>

<file path="flake.lock">
{
  "nodes": {
    "flake-utils": {
      "inputs": {
        "systems": "systems"
      },
      "locked": {
        "lastModified": 1731533236,
        "narHash": "sha256-l0KFg5HjrsfsO/JpG+r7fRrqm12kzFHyUHqHCVpMMbI=",
        "owner": "numtide",
        "repo": "flake-utils",
        "rev": "11707dc2f618dd54ca8739b309ec4fc024de578b",
        "type": "github"
      },
      "original": {
        "owner": "numtide",
        "repo": "flake-utils",
        "type": "github"
      }
    },
    "nixpkgs": {
      "locked": {
        "lastModified": 1764950072,
        "narHash": "sha256-BmPWzogsG2GsXZtlT+MTcAWeDK5hkbGRZTeZNW42fwA=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "f61125a668a320878494449750330ca58b78c557",
        "type": "github"
      },
      "original": {
        "owner": "NixOS",
        "ref": "nixos-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "flake-utils": "flake-utils",
        "nixpkgs": "nixpkgs"
      }
    },
    "systems": {
      "locked": {
        "lastModified": 1681028828,
        "narHash": "sha256-Vy1rq5AaRuLzOxct8nz4T6wlgyUR7zLU309k9mBC768=",
        "owner": "nix-systems",
        "repo": "default",
        "rev": "da67096a3b9bf56a91d16901293e51ba5b49a27e",
        "type": "github"
      },
      "original": {
        "owner": "nix-systems",
        "repo": "default",
        "type": "github"
      }
    }
  },
  "root": "root",
  "version": 7
}
</file>

<file path="flake.nix">
{
  description = "Multi-platform dev shell with VSCode + Playwright browsers";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs =
    {
      self,
      nixpkgs,
      flake-utils,
    }:
    flake-utils.lib.eachDefaultSystem (
      system:
      let
        pkgs = import nixpkgs {
          inherit system;
        };
      in
      {
        devShells.default = pkgs.mkShell {
          nativeBuildInputs = with pkgs; [
            nodejs
            playwright-driver.browsers
          ];

          shellHook = ''
            export PLAYWRIGHT_BROWSERS_PATH=${pkgs.playwright-driver.browsers}
            export PLAYWRIGHT_SKIP_VALIDATE_HOST_REQUIREMENTS=true
          '';
        };
      }
    );
}
</file>

<file path="next.config.js">
// eslint-disable-next-line @typescript-eslint/no-var-requires
const withMDX = require('@next/mdx')({
  extension: /\.mdx?$/,
  options: {
    // If you use remark-gfm, you'll need to use next.config.mjs
    // as the package is ESM only
    // https://github.com/remarkjs/remark-gfm#install
    remarkPlugins: [],
    rehypePlugins: ["rehypeMdxCodeProps"],
    // If you use `MDXProvider`, uncomment the following line.
    // providerImportSource: "@mdx-js/react",
  },
})

/** @type {import('next').NextConfig} */
const nextConfig = {
  headers: () => [
    {
      source: '/Search/:path*',
      headers: [
        {
          key: 'Cache-Control',
          value: 'no-store',
        },
      ],
    },
  ],
  images: {
    domains: ["google.com"]
  },
  // Configure pageExtensions to include md and mdx
  pageExtensions: ['ts', 'tsx', 'js', 'jsx', 'md', 'mdx'],
  // Optionally, add any other Next.js config below
  reactStrictMode: true,
  transpilePackages: ["api"],
  async rewrites() {
    return [
      {
        source: "/api/:path*",
        destination: "http://localhost:3000/api/:path*",
      },
    ];
  },

}

// Merge MDX config with Next.js config
module.exports = withMDX(nextConfig)
</file>

<file path="postcss.config.cjs">
module.exports = {
  plugins: {
    '@pandacss/dev/postcss': {},
  },
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="app/Blogs/[slug]/layout.tsx">
import { Navbar } from "../../components/shared/Navbar";
import { BlogNavbarWrapper } from "../../components/blog/BlogNavbarWrapper";
import { css } from "../../../styled-system/css";

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <div className={css({ px: "layout", pt: "layout" })}>
      <BlogNavbarWrapper>
        <Navbar mode="sticky" />
      </BlogNavbarWrapper>
      {children}
    </div>
  )
}
</file>

<file path="app/Blogs/[slug]/page.tsx">
"server-only";

import React from "react";
import { css } from "../../../styled-system/css";
import { getAllPosts, getPostBySlug } from "../../../lib/blogs";
import { MDXRemote } from "next-mdx-remote/rsc";
import { mdxOptions } from "../../../lib/mdx";
import "highlight.js/styles/atom-one-dark.css";

export async function generateStaticParams() {
  const blogs = getAllPosts();

  const paths = blogs.map((blog) => ({
    slug: blog.slug,
  }));

  return paths;
}

export async function generateMetadata({ params }: { params: { slug: string } }) {
  const blog = getPostBySlug(params.slug);

  if (blog)
    return {
      title: blog.meta.title,
      description: blog.meta.description,
    };
}

export default async function Post({ params }: { params: { slug: string } }) {
  try {
    const blog = getPostBySlug(params.slug);

    if (blog) {
      return (
        <div
          className={css({
            opacity: 0.7,
            borderRadius: "10px",
            boxShadow: "#00000F 0 0 10px",
            bg: "#000000",
            w: { base: "100%", md: "90%", lg: "80%" },
            mx: "auto",
            p: "6",
            mb: "layout",
            mt: "layout",
          })}
        >
          <div
            className={css({
              maxWidth: "65ch",
              mx: "auto",
              color: "white",
              "& h1": { fontSize: "3xl", fontWeight: "bold", mt: "2rem", mb: "1rem" },
              "& h2": { fontSize: "2xl", fontWeight: "bold", mt: "1.5rem", mb: "0.75rem" },
              "& h3": { fontSize: "xl", fontWeight: "bold", mt: "1.25rem", mb: "0.5rem" },
              "& p": { mb: "1rem", lineHeight: "relaxed" },
              "& ul": { listStyleType: "disc", pl: "1.5rem", mb: "1rem" },
              "& ol": { listStyleType: "decimal", pl: "1.5rem", mb: "1rem" },
              "& li": { mb: "0.5rem" },
              "& blockquote": {
                borderLeftWidth: "4px",
                borderLeftColor: "gray.500",
                pl: "1rem",
                fontStyle: "italic",
                my: "1rem",
              },
              "& pre": {
                bg: "transparent",
                p: "1rem",
                borderRadius: "md",
                overflowX: "auto",
                mb: "1rem",
                fontSize: "sm",
                lineHeight: "1.6",
              },
              "& .hljs": {
                bg: "transparent !important",
              },
              "& code": {
                fontFamily: "mono",
                bg: "rgba(255,255,255,0.1)",
                px: "0.2em",
                borderRadius: "sm",
                fontSize: "0.9em",
              },
              "& pre code": {
                bg: "transparent",
                p: "0",
              },
              "& a": {
                color: "blue.400",
                textDecoration: "underline",
                _hover: { color: "blue.300" },
              },
              "& img": {
                maxWidth: "100%",
                height: "auto",
                borderRadius: "md",
                my: "1rem",
              },
              "& hr": {
                borderColor: "gray.700",
                my: "2rem",
              },
            })}
          >
            <div className={css({ mb: "5" })}>
              <h1 className={css({ fontWeight: "bold", fontSize: "3xl", xl: { mt: "24" }, mb: "0" })}>
                {blog.meta.title}
              </h1>
              <time className={css({ color: "gray.500", fontStyle: "italic" })}>{blog.meta.date}</time>
              <div className={css({ borderBottomWidth: "1px", borderBottomColor: "white", w: "full", mt: "5" })} />
            </div>
            <MDXRemote source={blog.content} options={mdxOptions} />
          </div>
        </div>
      );
    }
  } catch (error) {
    console.error(error);
    return <p>something broke or this blog doesnt exist :/</p>;
  }
}
</file>

<file path="app/components/home/Card.tsx">
import * as React from "react";
import { css } from "../../../styled-system/css";
import { Route } from "../shared/Route";
import { IconDefinition } from "@fortawesome/fontawesome-svg-core";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";

export interface CardProps {
  title: string;
  desc: string;
  icon?: IconDefinition;
  color: string;
  href: string;
}

export const Card = ({ title, desc, icon, color, href }: CardProps) => {
  return (
    <div className={css({ display: "flex", justifyContent: "space-between" })}>
      <div>
        <Route href={href} size={30} color={color}>
          <h3
            className={css({
              fontSize: "2xl",
              fontWeight: "bold",
              _hover: { color: "white" },
            })}
          >
            {title}
          </h3>
        </Route>

        {/* Description spacing now matches LatestBlog mobile */}
        <p
          className={css({
            color: "gray.400",
            fontSize: "sm",
            //paddingTop: "-5",
            mt: "1", // üëà adds breathing room under title
            lineHeight: "short", // üëà matches blog card text rhythm
          })}
        >
          {desc}
        </p>
      </div>

      <div
        className={css({
          display: "flex",
          flexDirection: "column",
          justifyContent: "center",
          alignItems: "center",
        })}
      >
        {icon ? <FontAwesomeIcon icon={icon} size="xl" /> : null}
      </div>
    </div>
  );
};
</file>

<file path="app/components/home/index.ts">
/**
 * Home page components
 */

export { Card } from "./Card";
export type { CardProps } from "./Card";

export { Socials } from "./Socials";

export { BebopContainer } from "./BebopContainer";

export { Bebop } from "./Bebop";

//export { MobileLayout } from "./MobileScrollContainer";

//export { LatestBlogCard } from "./LatestBlogCard";

export { HomeNav } from "./HomeNav";
</file>

<file path="app/components/home/MobileScrollContainer.tsx">
"use client";

import { motion } from "framer-motion";
import { ReactNode } from "react";
import { css } from "../../../styled-system/css";
import { layoutCalc } from "../../../lib/layout";
import { useScrollFadeAnimation, useMobileDetection } from "../../../hooks";

interface MobileLayoutProps {
  navbar: ReactNode;
  children: ReactNode;
}

/**
 * Mobile-only layout container with scroll-based navbar animation.
 * The navbar starts as part of the layout flow, then fades out on scroll
 * while content shifts up to fill the space.
 *
 * Now uses the extracted useScrollFadeAnimation and useMobileDetection hooks.
 */
export const MobileLayout = ({ navbar, children }: MobileLayoutProps) => {
  const { opacity, y, marginBottom } = useScrollFadeAnimation();
  const { isMobile, hasMounted } = useMobileDetection();

  // Navbar container styles - fluid width with margins
  const navbarContainerStyles = css({
    alignSelf: "stretch", // Fill parent width
    mx: "layout", // Apply standard layout margin (12px)
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
  });

  // Don't render on desktop or before hydration
  if (!hasMounted) {
    // SSR/initial render - show mobile layout without animation
    return (
      <div
        className={css({
          lg: { display: "none" },
          w: "100%", // Changed from 100vw to prevent horizontal scroll
          display: "flex",
          flexDirection: "column",
          alignItems: "center",
        })}
      >
        {/* Navbar with edge margins like desktop */}
        <div
          className={css({
            alignSelf: "stretch",
            mx: "layout",
            mb: "layout",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
          })}
        >
          {navbar}
        </div>
        {children}
      </div>
    );
  }

  // Removed JS-based desktop check to prevents gaps during resize.
  // We rely on the CSS 'lg: { display: "none" }' below to hide this on desktop.

  /* if (!isMobile) {
        return null;
    } */

  return (
    <div
      className={css({
        lg: { display: "none" },
        w: "100%", // Changed from 100vw to prevent horizontal scroll caused by vertical scrollbar
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        pt: "layout", // Top padding like desktop navbar has
      })}
    >
      {/* Animated navbar container - full width with edge margins */}
      <motion.div
        style={{
          opacity,
          y,
          marginBottom,
        }}
        className={navbarContainerStyles}
      >
        {navbar}
      </motion.div>
      {/* Content */}
      {children}
    </div>
  );
};
</file>

<file path="app/components/search/Badges.tsx">
import { css } from "../../../styled-system/css";

const badgeStyle = (bgColor: string, textColor: string, darkBg: string, darkText: string) =>
  css({
    bg: bgColor,
    color: textColor,
    fontSize: "xs",
    fontWeight: "medium",
    mr: "2",
    px: "2.5",
    py: "0.5",
    borderRadius: "full",
    _dark: { bg: darkBg, color: darkText },
  });

const TechBadge = () => <span className={badgeStyle("blue.100", "blue.800", "blue.900", "blue.300")}>Tech</span>;

const JSBadge = () => <span className={badgeStyle("gray.100", "gray.800", "gray.700", "gray.300")}>JavaScript</span>;

const PhilosophyBadge = () => <span className={badgeStyle("red.100", "red.800", "red.900", "red.300")}>Philosophy</span>;

const WritingBadge = () => <span className={badgeStyle("green.100", "green.800", "green.900", "green.300")}>Writing</span>;

const ShitpostBadge = () => <span className={badgeStyle("yellow.100", "yellow.800", "yellow.900", "yellow.300")}>Shitpost</span>;

const CommentaryBadge = () => <span className={badgeStyle("indigo.100", "indigo.800", "indigo.900", "indigo.300")}>Commentary</span>;

const GenericBadge = ({ text }: { text: string }) => (
  <span className={badgeStyle("gray.100", "gray.800", "gray.700", "gray.300")}>{text}</span>
);

export type tags =
  | "tech"
  | "writing"
  | "commentary"
  | "philosophy"
  | "shitpost"
  | "js"
  | string; // Allow other strings

export const DescriptionTags = (tags: tags[]) => {
  const components = [] as JSX.Element[];
  const safeTags = Array.isArray(tags) ? tags : [];
  safeTags.forEach((el, i) => {
    if (i < 3) { // Increased limit slightly
      const tag = el.toLowerCase();
      if (tag === "tech") {
        components.push(<TechBadge key={i} />);
      } else if (tag === "writing") {
        components.push(<WritingBadge key={i} />);
      } else if (tag === "commentary") {
        components.push(<CommentaryBadge key={i} />);
      } else if (tag === "philosophy") {
        components.push(<PhilosophyBadge key={i} />);
      } else if (tag === "shitpost") {
        components.push(<ShitpostBadge key={i} />);
      } else if (tag === "js") {
        components.push(<JSBadge key={i} />);
      } else {
        components.push(<GenericBadge key={i} text={el} />);
      }
    }
  });
  return components;
};
</file>

<file path="app/components/shared/Route.tsx">
"use client";

import { css, cx } from "@/styled-system/css";
import { ReactNode, useState, useEffect } from "react";
import { Loading } from "./Loading";

export interface RouteProps {
  children: ReactNode;
  href: string;
  color?: string;
  className?: string;
  size: number;
}

/**
 * A link component with loading state indicator.
 * Shows a loading animation for 3 seconds after click.
 */
export const Route = ({
  children,
  href,
  color,
  className,
  size,
}: RouteProps) => {
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    const timer = setTimeout(() => setLoading(false), 3000);
    return () => clearTimeout(timer);
  }, [loading]);

  const isExternal = href.startsWith("https://");

  return (
    <a
      style={{ color }}
      href={href}
      target={isExternal ? "_blank" : undefined}
      rel={isExternal ? "noopener noreferrer" : undefined}
      className={cx(className, css({ _hover: { color: "white" } }))}
      onClick={() => {
        if (!isExternal) setLoading(true);
      }}
    >
      {!loading ? children : <Loading fontsize={size} />}
    </a>
  );
};
</file>

<file path="app/globals.css">
@layer reset, base, tokens, recipes, utilities;

@layer utilities {
  [class*="bebop_svg__path"] {
    stroke-dasharray: 5000;
    stroke-dashoffset: 5000;
    animation: dash 5s linear alternate infinite;
  }

  .topGradient {
    background: linear-gradient(180deg,
        rgba(0, 0, 0, 1) 40%,
        rgba(255, 255, 255, 1) 90%);
  }

  .smoothInputCusor {
    color: transparent;
    text-shadow: 0 0 0 #2196f3;
    transition: all 0.8s !important;
  }

  .mobileparentsize {
    min-height: calc(100vh - 60px);
  }
}

@font-face {
  font-family: "pixel";
  src: local("pixel"), url("/fonts/pixeldown.ttf") format("truetype");
  font-weight: bold;
}

body {
  background-color: #581F37;
  min-height: 100vh;
  width: 100%;
  overflow-x: hidden;
}

.fancyFont {
  font-family: "pixel";
}


/* Animation */
.anim-typewriter {
  position: relative;
  border-right: 2px solid rgba(0, 0, 0, 0.75);
  white-space: nowrap;
  overflow: hidden;

  animation: typewriter 2s steps(44) 1s 1 normal both,
    blinkTextCursor 500ms steps(44) infinite normal;
}

@keyframes typewriter {
  from {
    width: 0;
  }

  to {
    width: 100%;
  }
}

@keyframes blinkTextCursor {
  from {
    border-right-color: rgba(0, 0, 0, 0.75);
  }

  to {
    border-right-color: transparent;
  }
}

@keyframes dash {
  from {
    stroke-dashoffset: 5000;
  }

  to {
    stroke-dashoffset: 0;
  }
}

/* Hide scrollbar globally while preserving scroll */
html {
  scrollbar-width: none;
  /* Firefox */
  -ms-overflow-style: none;
  /* IE/Edge */
}

html::-webkit-scrollbar {
  display: none;
  /* Chrome/Safari/Opera */
}

/* Code block horizontal scrollbar - inverted colors */
pre::-webkit-scrollbar {
  height: 8px;
}

pre::-webkit-scrollbar-track {
  background: #000000;
  border-radius: 8px;
}

pre::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.6);
  border-radius: 8px;
}

pre::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.8);
}

/* Firefox scrollbar styling for pre elements */
pre {
  scrollbar-width: thin;
  scrollbar-color: rgba(255, 255, 255, 0.6) #000000;
}
</file>

<file path="lib/mdx.ts">
import rehypeHighlight from "rehype-highlight";
import nim from "highlight.js/lib/languages/nim";
import { all } from "lowlight";
import type { MDXRemoteProps } from "next-mdx-remote/rsc";

export const mdxOptions: MDXRemoteProps["options"] = {
  mdxOptions: {
    rehypePlugins: [
      [
        rehypeHighlight,
        {
          languages: all,
        },
      ],
    ],
  },
};
</file>

<file path="README.md">
This is a [Next.js](https://nextjs.org/) project bootstrapped with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/basic-features/font-optimization) to automatically optimize and load Inter, a custom Google Font.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js/) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/deployment) for more details.
</file>

<file path="app/components/home/LatestBlogCard.tsx">
import { Suspense } from "react";
import Image from "next/image";
import { Loading } from "../shared/Loading";
import { DescriptionTags, tags } from "../search/Badges";
import Link from "next/link";
import { css } from "../../../styled-system/css";
import { getAllPosts } from "../../../lib/blogs";

const LoadingCard = () => {
  return (
    <div
      className={css({
        w: "full",
        h: "full",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
      })}
    >
      <Loading fontsize={30} />
    </div>
  );
};

const FetchBlogs = async () => {
  const allBlogs = getAllPosts();
  const blogs = allBlogs.slice(0, 3);

  return (
    <ul className={css({ overflowY: "auto", flex: 1, minH: 0 })}>
      {blogs.map((blog) => {
        const tagBadges = DescriptionTags(blog.meta.tags as tags[]);

        return (
          <Link
            href={"/Blogs/" + blog.slug}
            className={css({
              display: "flex",
              flexDirection: "row",
              justifyContent: "space-between",
              alignItems: "center",
              color: "gray.800",
              mb: "3",
              overflow: "hidden",
              textOverflow: "ellipsis",
              wordBreak: "break-word",
            })}
            key={blog.slug}
            data-group
          >
            {blog.meta.image ? (
              <>
                <div
                  className={css({
                    display: "flex",
                    flexDirection: "column",
                    maxW: "120",
                    gap: "2",
                  })}
                >
                  <div>
                    <h3
                      className={css({
                        fontSize: "xl",
                        fontWeight: "bold",
                        color: "white",
                      })}
                    >
                      {blog.meta.title}
                    </h3>
                    <p className={css({ color: "gray.400" })}>
                      {blog.meta.date}
                    </p>

                    {/* MOBILE DESCRIPTION */}
                    <p
                      className={css({
                        display: { base: "block", lg: "none" },
                        color: "gray.400",
                        fontSize: "sm",
                        mt: "1",
                        lineHeight: "short",
                      })}
                    >
                      {blog.meta.description}
                    </p>
                  </div>

                  {/* DESKTOP TAGS */}
                  <div
                    className={css({
                      display: { base: "none", lg: "flex" },
                      flexWrap: "wrap",
                      gap: "1",
                      opacity: 0,
                      transition: "opacity 0.2s ease-in-out",
                      _groupHover: { opacity: 1 },
                    })}
                  >
                    {tagBadges}
                  </div>
                </div>

                <Suspense fallback={LoadingCard()}>
                  <Image
                    src={blog.meta.image}
                    alt="blogcontent"
                    width={200}
                    height={200}
                  />
                </Suspense>
              </>
            ) : (
              <div
                className={css({
                  display: "flex",
                  flexDirection: "column",
                  flex: 1,
                  gap: "1",
                })}
              >
                <div
                  className={css({
                    display: "flex",
                    flexDirection: "row",
                    justifyContent: "space-between",
                    alignItems: "center",
                  })}
                >
                  <h3
                    className={css({
                      fontSize: "xl",
                      fontWeight: "bold",
                      color: "white",
                    })}
                  >
                    {blog.meta.title}
                  </h3>
                  <p className={css({ color: "gray.400" })}>{blog.meta.date}</p>
                </div>

                {/* MOBILE DESCRIPTION */}
                <p
                  className={css({
                    display: { base: "block", lg: "none" },
                    color: "gray.400",
                    fontSize: "sm",
                    lineHeight: "short",
                  })}
                >
                  {blog.meta.description}
                </p>

                {/* DESKTOP TAGS */}
                <div
                  className={css({
                    display: { base: "none", lg: "flex" },
                    flexWrap: "wrap",
                    gap: "1",
                    opacity: 0,
                    transition: "opacity 0.2s ease-in-out",
                    _groupHover: { opacity: 1 },
                  })}
                >
                  {tagBadges}
                </div>
              </div>
            )}
          </Link>
        );
      })}
    </ul>
  );
};

const LoadingLatest = () => (
  <div
    className={css({
      w: "full",
      h: "full",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
    })}
  >
    <Loading fontsize={30} />
  </div>
);

export const LatestBlogCard = () => {
  return (
    <div
      className={css({
        px: { sm: "20", lg: "5", base: "5" },
        py: "5",
        h: "full",
        minH: 0,
        overflow: "hidden",
        display: "flex",
        flexDirection: "column",
      })}
    >
      <h3
        className={css({
          fontSize: "2xl",
          fontWeight: "bold",
          color: "blue.300",
        })}
      >
        Latest
      </h3>
      <hr className={css({ my: "5" })} />
      <div
        className={css({
          w: "full",
          flex: 1,
          minH: 0,
          display: "flex",
          flexDirection: "column",
          justifyContent: "center",
          overflow: "hidden",
        })}
      >
        <Suspense fallback={<LoadingLatest />}>
          <FetchBlogs />
        </Suspense>
      </div>
    </div>
  );
};
</file>

<file path="app/components/search/SearchWrapper.tsx">
"use client";

import React, { useMemo, useState } from "react";
import { css } from "../../../styled-system/css";
import { BlogPost } from "../../../lib/blogs";
import { TreeNode } from "./TreeNode";
import { AnimatePresence } from "framer-motion";

export const SearchWrapper = ({ posts }: { posts: BlogPost[] }) => {
  const [search, setSearch] = useState("");

  const filteredPosts = useMemo(() => {
    const searchLower = search.toLowerCase();
    return posts.filter((post) => {
      const tags = Array.isArray(post.meta.tags) ? post.meta.tags : [];
      return (
        post.meta.title.toLowerCase().includes(searchLower) ||
        post.meta.description.toLowerCase().includes(searchLower) ||
        tags.some((tag) => tag.toLowerCase().includes(searchLower))
      );
    });
  }, [posts, search]);

  return (
    <div
      className={css({
        w: "full",
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        pb: "layout",
      })}
    >
      {/* Glassy sticky header strip */}
      <div
        className={css({
          w: "full",
          position: "sticky",
          top: "navHeight",
          zIndex: 40,
          display: "flex",
          justifyContent: "center",
          backdropFilter: "blur(10px)",
          mb: "layout",
        })}
      >
        <div
          className={css({
            w: "full",
            maxW: "800px",
          })}
        >
          <input
            type="text"
            placeholder="Search blogs..."
            value={search}
            onChange={(e) => setSearch(e.target.value)}
            className={css({
              w: "100%",
              p: "5",
              bg: "#000000",
              opacity: 0.7,
              borderRadius: "10px",
              boxShadow: "#00000F 0 0 10px",
              color: "white",
              outline: "none",
              fontSize: "xl",
              _focus: {
                borderColor: "white",
                boxShadow: "0 0 15px rgba(255,255,255,0.4)",
              },
              transition: "all 0.3s ease",
            })}
          />
        </div>
      </div>

      {/* Tree List */}
      <div
        className={css({
          display: "flex",
          flexDirection: "column",
          w: "full",
          alignItems: "center",
          gap: "layout",
        })}
      >
        {filteredPosts.map((blog, index) => (
          <TreeNode
            key={blog.slug}
            blog={blog}
            depth={0}
            isFirst={index === 0}
            isLast={index === filteredPosts.length - 1}
          />
        ))}
      </div>
    </div>
  );
};
</file>

<file path="app/layout.tsx">
/* eslint-disable @next/next/no-img-element */
import "./globals.css";
import { css } from "../styled-system/css";
import "@fortawesome/fontawesome-svg-core/styles.css";
import { config } from "@fortawesome/fontawesome-svg-core";
import { Analytics } from "@vercel/analytics/next";
config.autoAddCss = false;

export const metadata = {
  title: 'becker63',
  description: 'Generated by create next app',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en" className={css({ color: "white" })}>
      <body>
        <img
          className={css({
            zIndex: "0",
            position: "fixed",
            inset: "0",
            margin: "auto",
            maxWidth: "70%",
            height: "auto",
            width: "auto",
            pointerEvents: "none",
          })}
          src="/img/backgroundImage.jpg"
          alt="blogcontent"
        />
        <div className={css({ position: "relative", zIndex: "1" })}>
          {children}
        </div>
        <Analytics />
      </body>
    </html>
  )
}
</file>

<file path="app/page.tsx">
import { HomeMobileLayout } from "./components/home/HomeMobileLayout";
import { HomeDesktopLayout } from "./components/home/HomeDesktopLayout";

export default function Home() {
  return (
    <>
      <HomeMobileLayout />
      <HomeDesktopLayout />
    </>
  );
}
</file>

<file path=".eslintrc">
{
  "extends": [
    "next"
  ]
}
</file>

<file path="panda.config.ts">
import { defineConfig } from "@pandacss/dev";

export default defineConfig({
  // Whether to use css reset
  preflight: true,

  // Where to look for your css declarations
  include: [
    "./pages/**/*.{js,jsx,ts,tsx}",
    "./components/**/*.{js,jsx,ts,tsx}",
    "./app/**/*.{js,jsx,ts,tsx}",
    "./lib/**/*.{js,jsx,ts,tsx}",
  ],

  // Files to exclude
  exclude: [],

  // Useful for theme customization
  theme: {
    extend: {
      breakpoints: {
        xsm: "400px",
        sm: "640px",
        md: "768px",
        lg: "1024px",
        xl: "1280px",
        "2xl": "1536px",
      },
      tokens: {
        spacing: {
          layout: { value: "{spacing.3}" }, // 12px
          navHeight: { value: "70px" }, // 57px (nav bottom) + 13px gap = 70px
        },
      },
      layerStyles: {
        navbar: {
          description: "Glassy standard navbar",
          value: {
            zIndex: 50,
            bg: "black",
            px: { base: "2", sm: "4" },
            opacity: 0.7,
            borderRadius: "10px",
            boxShadow: "#00000F 0 0 10px",
            top: "{spacing.layout}",
            left: "{spacing.layout}",
            right: "{spacing.layout}",
            mb: "{spacing.layout}",
          } as any,
        },
        pageContainer: {
          description: "Top-level page container matching fixed navbar",
          value: {
            pt: "{spacing.navHeight}",
            pb: "{spacing.layout}",
          } as any,
        },
        pageWithMargins: {
          description: "Page container with consistent viewport margins matching navbar",
          value: {
            pt: "{spacing.navHeight}",
            pb: "{spacing.layout}",
            px: "{spacing.layout}",
            minH: "100vh",
            w: "100%",
            boxSizing: "border-box",
          } as any,
        },
      },
      keyframes: {
        typewriter: {
          from: { width: "0" },
          to: { width: "100%" },
        },
        blinkTextCursor: {
          from: { borderRightColor: "rgba(0, 0, 0, 0.75)" },
          to: { borderRightColor: "transparent" },
        },
        dash: {
          from: { strokeDashoffset: "1000" },
          to: { strokeDashoffset: "0" },
        },
      },
    },
  },

  // The output directory for your css system
  outdir: "styled-system",
});
</file>

<file path="app/components/shared/Navbar.tsx">
import { css } from "../../../styled-system/css";
import "./shared.css";
import { Route } from "./Route";

export interface NavbarProps {
  mode?: "fixed" | "sticky";
}

/**
 * Global navigation bar component with glass effect styling.
 * Displays the site title and navigation links.
 */
export const Navbar = ({ mode = "fixed" }: NavbarProps) => {
  return (
    <nav
      className={css({
        layerStyle: "navbar",
        position: mode,
      })}
    >
      <div
        className={css({
          display: "flex",
          flexWrap: "wrap",
          justifyContent: "space-between",
          alignItems: "center",
          mx: "auto",
          w: "100%",
          maxW: "1536px",
        })}
      >
        <a href="#" className={css({ display: "flex" })}>
          <span
            className={`anim-typewriter ${css({
              alignSelf: "center",
              fontSize: "30px",
              fontWeight: "semibold",
              whiteSpace: "nowrap",
              color: "white",
              fontFamily: "pixel, sans-serif",
            })}`}
          >
            becker63
          </span>
        </a>

        <ul className={css({ display: "flex" })}>
          <li>
            <Route
              color="#0097fc"
              href="/"
              className={css({
                display: "block",
                py: "2",
                px: { base: "1", sm: "4" },
                pl: "3",
                fontSize: "15px",
              })}
              size={20}
            >
              <h3 className={css({ _hover: { color: "white" } })}>Home</h3>
            </Route>
          </li>
          <li>
            <Route
              color="#FCA5A5"
              href="/Search"
              className={css({
                display: "block",
                py: "2",
                px: { base: "1", sm: "4" },
                pl: "3",
                fontSize: "15px",
              })}
              size={20}
            >
              <h3 className={css({ _hover: { color: "white" } })}>Blogs</h3>
            </Route>
          </li>
          <li>
            <Route
              color="#86EFAC"
              href="/Blogs/designing-for-two"
              className={css({
                display: "block",
                py: "2",
                px: { base: "1", sm: "4" },
                pl: "3",
                fontSize: "15px",
              })}
              size={20}
            >
              <h3 className={css({ _hover: { color: "white" } })}>Portfolio</h3>
            </Route>
          </li>
        </ul>
      </div>
    </nav>
  );
};
</file>

<file path="app/Search/page.tsx">
import React from "react";
import { SearchWrapper } from "../components/search/SearchWrapper";
import { getAllPosts } from "../../lib/blogs";
import { css } from "../../styled-system/css";

export default function BlogHomepage() {
  const posts = getAllPosts();

  return (
    <>
      <div
        className={css({
          layerStyle: "pageWithMargins",
        })}
      >
        <SearchWrapper posts={posts} />
      </div>
    </>
  );
}
</file>

<file path="content/posts/designing-for-two.mdx">
---
title: Designing for two
date: '31 December 2025'
description: on infra configuration tooling
tags: tech
---

Modern cloud work is hard. I‚Äôve seen this firsthand from both sides ‚Äî developers trying to ship features, and operators trying to keep systems coherent as they scale.

In response, the industry has produced an enormous body of tooling to manage complexity. Entire subindustries now exist around scheduling, isolation, observability, and deployment. We have systems like Kubernetes and HashiCorp Nomad for scheduling, containers and microVMs for isolation, and observability satacks built on OpenTelemetry, Prometheus, and Grafana.

These components are mature, powerful, and widely accessible. The internet has had time to grow up, and it shows. I‚Äôm genuinely proud of what this industry has built. The CNCF landscape is an incredible artifact of collective engineering effort.

![cncf map](https://www.netlify.com/v3/img/blog/cncf-landscape-map-2020.jpg)

But that pride comes with a quieter anxiety. The same ecosystem that demonstrates our success also reflects the cognitive and organizational burden placed on teams. Even the CNCF seems to acknowledge this ‚Äî ‚ÄúOverwhelmed? Please see the CNCF Trail Map.‚Äù

My read is that much of this tension comes from how we coordinate across such a vast surface area. Many of the tools we rely on are deliberately general-purpose: maximally expressive, broadly applicable, and flexible enough to model almost anything. In practice, however, real teams are heterogeneous. They consist of people with different intuitions, tolerances for abstraction, and relationships to code.

Some engineers thrive inside a Turing-complete configuration language. Others prefer constrained, declarative systems. Some are comfortable writing shell glue; others actively avoid it. Generalist tools flatten these differences, often pushing complexity into shadow work ‚Äî ad-hoc scripts, translation layers, and tests written to recover clarity that the tooling itself cannot express directly.

This project grew out of an attempt to address that tension more directly.

---

## Coordination as a design problem

I approached these challenges by studying how existing tools resolve coordination in practice, and by experimenting with alternative ways of composing those tools to make their tradeoffs more legible.

My project is motivated by a different core principle than much of the existing tooling: **less power, more understanding** ‚Äî where power is the ability to express arbitrary behavior, and understanding is the ability to reason locally about outcomes.

I first developed these intuitions in application systems, where state and behavior were tightly coupled and often implicit. In those environments, ad-hoc abstractions and localized logic made global reasoning difficult, even when individual components were well-designed. Systems that instead made dataflow explicit ‚Äî modeling dependencies as directed graphs and centralizing state transitions ‚Äî dramatically improved correctness and debuggability. The same tradeoffs reappear at infrastructure scale, where hidden execution paths and implicit authority have even larger consequences.

The system I built exposes distinct interfaces for different audiences, designed to reinforce rather than obscure one another, while keeping both initial provisioning and ongoing operational change within a single, continuously reconciled control plane. Developers interact with it primarily through executable tests that assert deployment invariants. Operators work through schema-driven configuration that constrains and validates system shape. Hermetic build tooling ties these layers together without collapsing them into a single abstraction.

This project is a design experiment. It is not battle-tested at scale and should not be used in production. The goal is not replacement, but exploration.

There is also absolutely a time and a place for Terraform, YAML, and bash glue. Most organizations should coordinate around them. They have too much momentum to ignore, and they work extremely well for small to medium-sized teams.

But if you‚Äôre in a position to experiment, it‚Äôs worth paying attention to newer tooling and methodologies that have emerged from larger organizations over the past few years. To make that concrete, it helps to look at how existing tools resolve this problem today.

---

## Preexisting tooling

### Terraform

Terraform has, for good reason, become the de facto coordination layer for cloud infrastructure. It was the primary catalyst for the widespread adoption of Infrastructure as Code, and it remains the most widely deployed tool discussed here.

Terraform is pleasant to read. It borrows the most ergonomic parts of JSON, offers a simple static type system with solid editor support, and avoids unnecessary complexity. Its most important contribution, however, is its state model.

In real-world deployments involving multiple teams, the world changes underneath you. Machines are reassigned. IP addresses expire. Ownership shifts. Configuration alone is not enough to describe reality.

Terraform addresses this with a deceptively effective loop: refresh, plan, apply. Desired configuration is reconciled against stored state and the provider‚Äôs current view of the world. The resulting execution plan describes how to restore consistency, and the applied outcome becomes the new state.

This model enables drift tolerance, shared ownership, and long-lived systems. It also enforces a clear tradeoff: coordination is centralized.

The cost is operational. At any given moment, only one actor can safely perform the refresh‚Äìplan‚Äìapply cycle. Locks and workflows mitigate this, but do not remove the underlying constraint. For small teams this is often acceptable; for larger or more parallel organizations, the apply cycle becomes a scarce resource that shapes how work is planned and delegated.

Terraform succeeds by becoming the system of record for reality ‚Äî and that success inevitably shapes the organizations that adopt it.

---

### Pulumi

Terraform‚Äôs push-based reconciliation model proved so effective that most subsequent tools preserved it. Pulumi is best understood as one such iteration.

Rather than rejecting Terraform‚Äôs model, Pulumi reimplements it using general-purpose programming languages, shifting expressiveness and abstraction into user programs while keeping centralized state as the coordination primitive.

Architecturally, Pulumi consists of a Go-based engine and a set of language hosts that communicate with it over a defined RPC protocol. User programs run as normal processes in languages like TypeScript, Python, Go, or C#, but instead of mutating infrastructure directly, they register intent with the engine. Dependency tracking, diffing, ordering, and state persistence remain centralized.

This design is pragmatic and elegant. It allows Pulumi to support many languages without duplicating its core logic, and it lets organizations reuse their existing ecosystems wholesale. For application-centric teams, this is a powerful wedge.

Pulumi‚Äôs defining feature is that infrastructure intent can be expressed using the full abstraction power of the host language. Loops, conditionals, helper functions, and classes are all available, and infrastructure definitions can live directly alongside application code.

This is also where the core tradeoff appears.

By allowing intent to be expressed as the result of general-purpose program execution, Pulumi moves a significant amount of authority out of the tool and into user code. The shape of the desired system no longer exists as a static artifact; it is produced indirectly, by running a program.

In environments where infrastructure intent is primarily expressed through general-purpose code, authority tends to accumulate implicitly: in helper libraries, custom tooling, sidecar processes, and extension points that are difficult to inspect in isolation. Over time, onboarding becomes an exercise in reconstructing execution paths rather than reasoning about declared state. Even when individual components are well-designed, the system as a whole fragments into behavior that is correct but no longer legible.

This raises the bar for control planes, automation, and auditability. Systems that sit above infrastructure definition depend on stable, statically analyzable interfaces. Operators and administrators need to inspect intent without replaying arbitrary execution.

Pulumi does not make this impossible, but it enforces discipline culturally rather than structurally. In environments where application teams own infrastructure end-to-end, that tradeoff can be reasonable. My own interests lie elsewhere: in systems where control-plane boundaries are explicit, interfaces are static, and intent remains inspectable without executing arbitrary programs.

---

### CDK8s

At first glance, CDK8s appears similar to Pulumi. Both allow infrastructure to be authored in general-purpose languages and primarily target application developers.

The difference lies in scope and execution.

CDK8s is not a general-purpose cloud framework. It does not manage state, perform reconciliation, or call provider APIs. Instead, it focuses narrowly on Kubernetes, allowing users to define resources using object-oriented abstractions and then synthesize those definitions into static YAML. Application and reconciliation are left explicitly to downstream systems.

In that sense, CDK8s functions more like a compilation target than a control plane.

This was initially very attractive. CDK8s is intentionally constrained, produces artifacts that are legible to operators, and integrates cleanly with GitOps workflows. It eliminates a class of configuration errors without obscuring the underlying manifests.

Over time, however, two issues became difficult to ignore.

First, the object-oriented abstractions sit at a noticeable semantic distance from the YAML they generate. Writing and reviewing configurations required frequent context switching between representations of the same intent. As configurations grew ‚Äî especially when targeting systems like Crossplane ‚Äî that indirection made local reasoning harder rather than easier.

Second, CDK8s is explicitly an application-level abstraction over Kubernetes. Its strengths lie in ergonomic builders for well-known resources, not in serving as a substrate for control-plane-level composition across many CRDs.

Those edges clarified what I was actually looking for: a system that preserves static, inspectable artifacts, but with a simpler and more direct evaluation model.

---

### YAML and bash

At the far end of this spectrum sit YAML and shell scripts. Despite their limitations, they remain ubiquitous for a reason: they are flexible, transparent, and require very little machinery.

The cost is that execution and reconciliation are pushed almost entirely onto the user. There is no shared state, no formal notion of intent, and no control plane mediating change. Invariants live in documentation and convention rather than in the system itself.

For small teams, this tradeoff is often acceptable. As a general coordination model, however, YAML and bash offer few affordances for auditability, automation, or shared ownership. They expose execution without structure ‚Äî powerful precisely because they make no promises.

---

## The system I built

After evaluating Terraform, Pulumi, CDK8s, and raw YAML, I arrived at a conclusion that surprised me: these tools do not strain because they lack power, but because they collapse too many concerns into a single interface.

Infrastructure systems serve multiple audiences at once. Application developers want leverage. Operators want legibility and predictability. Platform and security teams want auditability and enforceable constraints. Most tools optimize for one of these roles and ask the rest to adapt.

This project explores a different approach: **separating power from authority**, and binding them back together through static, inspectable interfaces.

[`https://github.com/becker63/static-control-plane/`](https://github.com/becker63/static-control-plane/)

---

### A constrained control plane

At the center of the system is a Kubernetes-based control plane built on Crossplane. Unlike Terraform‚Äôs push-based apply loop, Crossplane exposes state continuously through Kubernetes objects. Desired and observed state live in the same substrate, making the system observable by default and naturally compatible with GitOps workflows.

This continuous reconciliation model also collapses the traditional distinction between ‚ÄúDay 1‚Äù provisioning and ‚ÄúDay 2‚Äù operations. Initial creation, drift remediation, scaling, replacement, and upgrade are all expressed through the same declarative topology and observed through the same control plane. Rather than handing systems off from a provisioning phase to an operational phase, Crossplane treats infrastructure as a long-lived object whose lifecycle remains visible, auditable, and correctable over time.

Crossplane‚Äôs native composition mechanisms are intentionally conservative. Rather than bypassing that constraint, I leaned into it.

All composition logic in this system is written using **KCL**, a small, non-Turing-complete language with a deliberately narrow execution model. KCL always evaluates to either valid Kubernetes manifests or a hard error. There is no synthesis step, no intermediate representation, and no opaque compilation target. Evaluation happens directly inside the control plane via a FluxCD controller that executes KCL as part of reconciliation.

This distinction matters.

KCL is not used here as a code generation language. It is used as a **structured, executable configuration format** whose syntax and semantics closely mirror JSON and YAML. Given the same inputs, it deterministically emits the same resources ‚Äî or fails loudly.

These KCL functions act as **pure transformations over observed state**. They cannot perform I/O, spawn processes, or introduce side effects. They exist entirely within the reconciliation loop and can only emit declarative resources.

The result is a control plane that is:

- statically analyzable,
    
- auditable by non-programmers,
    
- and safe to automate aggressively.
    

Operators can read the emitted YAML. Reviewers can diff it. CI systems can validate it. There is no hidden execution model.

---

### Code where it belongs

I did not want to give up the benefits of code entirely. Real systems require conditional logic, schema alignment, and cross-resource wiring that is brittle to express in raw YAML alone.

To address this, the system introduces **code only at the edges**, where it can be reasoned about locally and executed outside the control plane.

Schemas are generated from upstream sources ‚Äî CRDs, Go structs, and JSON Schema ‚Äî using hermetic build rules. These schemas are imported into KCL, providing strong typing and editor support without turning configuration into a general-purpose program.

Executable tests assert invariants about system topology rather than imperatively provisioning infrastructure. Build tooling (Buck2 + Nix) ensures that schema generation and evaluation are reproducible and independent of developer machines.

Crucially, none of this code runs as part of reconciliation.

In other words:

- **Code defines structure**, not outcomes.
    
- **Behavior emerges through reconciliation**, not scripts.
    
- **Authority flows through schemas**, not conventions.

---

These ideas become concrete at the boundaries of the system, where static intent meets a dynamic runtime. Configuration is authored as KCL functions that deterministically emit Kubernetes resources, while correctness is asserted through executable tests that observe reconciliation outcomes rather than driving provisioning imperatively. The goal is not to simulate Kubernetes, but to treat it as a system under observation whose behavior can be reasoned about through stable, inspectable artifacts.

The examples below make this split explicit. KCL is used as a JSON-like, declarative format that deterministically emits Kubernetes resources and nothing else. Expressive logic and validation live in Python, backed by fully typed APIs that observe reconciliation outcomes rather than orchestrating them. This separation keeps intent readable, behavior testable, and authority out of scripts.

```python
import schemas.kcl.fluxcd_helm_controller_kcl.models.v2.helm_toolkit_fluxcd_io_v2_helm_release as fluxcd_release

fluxcd_release.HelmRelease {
    metadata.name = "traefik"
    metadata.namespace = "traefik"
    spec = {
        interval = "10m"
        chart = {
            spec = {
                chart = "traefik"
                version = "21.2.0"
                sourceRef = {
                    kind = "HelmRepository"
                    name = "traefik"
                    namespace = "traefik"
                }
            }
        }
        install = {
            createNamespace = True
        }
    }
}
```

And its corresponding test.

```python
@make_kcl_named_test(["crossplane_release.k"], lambda kf: "helm_releases" in kf.path.parts)
def e2e_frp_kuttl(crossplane_release: KFile) -> None:
    # Run flux sync
    subprocess.run(["flux", "run"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

    # Parse HelmRelease from KCL output
    result = Exec(crossplane_release.path).json_result
    release = HelmRelease.model_validate(json.loads(result))
    metadata = release.metadata

    # Check required metadata fields
    if not metadata or not metadata.namespace or not metadata.name:
        raise ValueError("HelmRelease.metadata.namespace and name are required")

    namespace_name = metadata.namespace
    release_name = metadata.name

    # Ensure namespace exists
    try:
        Namespace.get(name=namespace_name)
        print(f"Namespace '{namespace_name}' already exists.")
    except ResourceNotFound:
        ns = Namespace.builder().metadata(lambda m: m.name(namespace_name)).build().create()
        for event, _ in ns.watch():
            if event == "ADDED":
                print(f"Namespace '{namespace_name}' created.")
                break

    # Ensure HelmRelease exists
    try:
        HelmRelease.get(name=release_name, namespace=namespace_name)
        print(f"HelmRelease '{release_name}' already exists.")
    except ResourceNotFound:
        for event, _ in release.create().watch(namespace=namespace_name):
            if event == "ADDED":
                print(f"HelmRelease '{release_name}' created.")
                break
```
## Conclusion

The tools we use to manage infrastructure are not neutral. They encode assumptions about who is allowed to act, how change is coordinated, and where authority lives. Over time, those assumptions shape teams as much as they shape systems.

Terraform centralizes coordination. Pulumi maximizes expressive power. CDK8s constrains execution while preserving authoring flexibility. YAML and bash trade guarantees for immediacy. None of these approaches are wrong ‚Äî but each makes a different trade between power, legibility, and control.

The system described here explores a different point in that design space. By treating infrastructure coordination as a **control-plane problem**, and by insisting on static, inspectable interfaces between roles, it becomes possible to automate aggressively without obscuring intent.

Infrastructure does not have to be either fully programmable or fully declarative. With deliberate constraints, it can be composed, audited, and shared across heterogeneous teams ‚Äî without asking everyone to trust the same abstractions.

That tradeoff ‚Äî **less power, more understanding** ‚Äî is the one I‚Äôm most interested in exploring.
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage
/test-results

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

## Panda
styled-system
styled-system-studio

app/_assets/svg/bebop.svg
public/svg/bebop.svg
</file>

<file path="package.json">
{
  "name": "next",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "prepare": "panda codegen",
    "test": "playwright test"
  },
  "dependencies": {
    "@fortawesome/fontawesome-svg-core": "^6.4.2",
    "@fortawesome/free-brands-svg-icons": "^6.4.2",
    "@fortawesome/free-solid-svg-icons": "^6.4.2",
    "@fortawesome/react-fontawesome": "^0.2.0",
    "@mdx-js/loader": "^2.3.0",
    "@next/mdx": "^13.5.5",
    "@vercel/analytics": "^1.6.1",
    "@xstate/react": "^6.0.0",
    "@zodyac/zod-mongoose": "^1.1.2",
    "framer-motion": "^12.29.0",
    "gray-matter": "^4.0.3",
    "highlight.js": "^11.11.1",
    "lowlight": "^3.3.0",
    "next-mdx-remote": "^5.0.0",
    "prism-themes": "^1.9.0",
    "react-inlinesvg": "^4.2.0",
    "rehype-highlight": "^7.0.2",
    "rehype-mdx-code-props": "^1.0.0",
    "rehype-prism-plus": "^2.0.1",
    "webpack": "^5.89.0",
    "xstate": "^5.24.0"
  },
  "devDependencies": {
    "@pandacss/dev": "^1.6.1",
    "@playwright/test": "1.54.1",
    "@svgr/webpack": "^8.1.0",
    "@types/node": "^20.8.7",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "eslint": "^8.51.0",
    "eslint-config-next": "^14.1.4",
    "next": "^14.2.1",
    "npm-run-all": "^4.1.5",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "typescript": "*"
  }
}
</file>

</files>
